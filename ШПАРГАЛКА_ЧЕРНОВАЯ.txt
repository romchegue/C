# File -> Reopen with Encoding -> Cyrillic (Windows 1251)

##### SWITCH-CASE

#include <iostream>
using namespace std;
int main()
{
    setlocale(LC_ALL, "Russian");
    float var1, var2;
    char Operator;
    cout << "Введите простое арифметическое выражение с двумя числами.\n(Пример: \'4 + 17\' или \'5 / 2\' и др.)" << endl;
    cin >> var1 >> Operator >> var2;
    switch (Operator)
    {
    case '+':
        cout << "Результат: " << var1 + var2 << endl;
        break;
    case '-':
        cout << "Результат: " << var1 - var2 << endl;
        break;
    case '*':
        cout << "Результат: " << var1 * var2 << endl;
        break;
    case '/':
        cout << "Результат: " << var1 / var2 << endl;
        break;
    default:
        cout << "Вы ввели неправильный операнд: " << var1 << " \<???\> " << var2 << endl;
        break;
    }

    return 0;
}


##### Цикл WHILE

#include <iostream>
using namespace std;
int main()
{
    setlocale(LC_ALL, "Russian");
    //cout << "Текст вывеля на экран" << endl;
    int a = 0;

    while (a < 10)
    {
        cout << "Переменная а = " << a << endl;
        a++;
    }

    return 0;
}


##### Цикл DO-WHILE

...
int main()
{
    setlocale(LC_ALL, "Russian");
    int a = 18;

    do
    {
        cout << "Переменная а = " << a << endl;
        a++;
    } while (a < 20);
    
    return 0;
}


##### ДОМАШНЕЕ ЗАДАНИЕ #4
/*1. Разработать программу, которая выводит на экран линию из символов. 
Число символов, какой использовать символ, и какая будет линия - вертикальная, 
или горизонтальная - указывает пользователь. */

#include <iostream>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    char symbol;  // символ
    int symbolCount;    // число символов
    int lineType;  // тип линии - горизонтальная или вертикальная

    cout << "[INFO] Эта программа выводит на экран линию из символов.\n" << endl;
    cout << "Введите количество символов в линии: ";
    cin >> symbolCount;
    cout << "Введите символ: ";
    cin >> symbol;
    cout << "Выберите тип линии:" << endl
        << "0 - горизонтальная линия" << endl
        << "1 - вертикальная линия" << endl;
    cin >> lineType;

    while (symbolCount > 0)
    {
        switch (lineType)
        {
        case 0:
        {
            cout << symbol;
            break;
        }
        case 1:
        {
            cout << symbol << endl;
            break;
        }
        default:
        {
            cout << "[ERROR] Введён неправильный тип линии" << endl;
            symbolCount = 0;
            break;
        }
        }
        symbolCount--;
    }


/*    switch (lineType)
    {
        case 0:
        {
            while (symbolCount > 0)
            {
                cout << symbol;
                symbolCount--;
            }
            break;
        }
        case 1:
        {
            while (symbolCount > 0)
            {
                cout << symbol << endl;
                symbolCount--;
            }
            break;
        }
        default:
            cout << "[ERROR] Введён неправильный тип линии";
            break;
    }
*/    
   
    cout << endl;

    return 0;
}


##### ДОМАШНЕЕ ЗАДАНИЕ #5
/*Написать программу, которая находит сумму всех целых 
нечетных чисел в диапазоне, указанном пользователе.

Разбор: https://youtu.be/gNoqm6aAzM0*/

#include <iostream>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    int rangeBegin, rangeEnd, sum=0;
    
    do
    {
        cout << "Введите на начальное и конечное значение диапазона целых чисел:" << endl;
        cin >> rangeBegin >> rangeEnd;
        if (rangeBegin > rangeEnd)
            cout << "[ERROR!] Начальное значение должно быть меньше или равно конечному!\n" << endl;
    } while (rangeBegin > rangeEnd);
               
    do
    {
        if (rangeBegin % 2 != 0)
        {
            sum += rangeBegin;
            cout << rangeBegin << " ";
        }
        rangeBegin++;
    } while (rangeBegin < rangeEnd);
    
    cout << endl << endl << "Сумма нечётных чисел равна " << sum << endl;

    /*    int start, end, i, sum = 0;
    cout << "Введите на начальное и конечное значение диапазона целых чисел:" << endl;
    cin >> start >> end;
    i = start;
    while (start <= i && i <= end)
    {
        if (i % 2 != 0)
            sum += i;
        i++;
    }
    cout << "Сумма нечетных чисел в диапазоне от " << start
        << " до " << end << " равна: " << sum << endl; */
    return 0;
}


##### Цикл FOR

#include <iostream>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");

    for (int i = 0, j = 10; i < 10 && j != 5; i++, j--)
    {
        cout << "Переменная i = " << i;
        cout << "     Переменная j = " << j << endl;
    }


    return 0;
}


##### Ключевое слово BREAK 
#include <iostream>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");

    cout << "Начало цикла" << endl;
    /*for (int i = 0; i < 10; i++)
    {
        cout << "Переменная i = " << i << endl;
        if (i == 5)
            break;
    } 

    int i = 0;
    while (true)
    {
        cout << "Переменная i = " << i << endl;
        i++;
        if (i == 6)
            break;
    } */


    cout << "Конец цикла" << endl;

    return 0;
}


##### Ключевое слово CONTINUE
#include <iostream>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");

    cout << "Начало цикла" << endl;
    for (int i = 0; i < 10; i++)
    {
        if (i == 5)
        {
            cout << endl;
            continue;
        }
            
        cout << "Переменная i = " << i << endl;
    } 

    cout << "Конец цикла" << endl;

    return 0;
}


###### Урок #21 - C++ закрывается консоль. Что делать? Задержка экрана консоли. 
#include <iostream>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    char c;

    cout << "Начало цикла" << endl;
    for (int i = 0; i < 10; i++)
    {
        if (i == 5)
        {
            cout << endl;
            continue;
        }
            
        cout << "Переменная i = " << i << endl;
    } 

    cout << "Конец цикла" << endl;
    system("pause");
    // cin >> c;
    
    return 0;
}


###### Урок #22 - оператор перехода GOTO
#include <iostream>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    cout << "Один" << endl;
    
    goto link;

    cout << "Два" << endl;

    cout << "Три" << endl;

    link:

    cout << "Четыре" << endl;

    cout << "Пять" << endl;

    return 0;
}


###### Урок #23 - работа с отладчиком
#include <iostream>
using namespace std;


int Sum(int a, int b)
{
    int c = a + b;
    return c;
}


int main()
{
    setlocale(LC_ALL, "Russian");
    int a = 4;
    int b = 6;
    int c;

    c = a + b;
    
    cout << c << endl;
    c = Sum(10, 20);
    cout << c << endl;
    return 0;
}


###### Урок #24 - Что такое вложенный цикл. Вложенная конструкция. C++ для начинающих. 
#include <iostream>
using namespace std;


int main()
{
    setlocale(LC_ALL, "Russian");

    for (int i = 1; i < 5; i++)
    {
        cout << "Сработал 1-й цикл for итерация № " << i << endl;
        for (int j = 1; j < 5; j++)
        {
            cout << "\tсработал 2-й цикл for итерация № " << j << endl;
        }

    }

    return 0;
}


###### Домашнее задание #6 - Вложенная конструкция. Вложенный цикл.
#include <iostream>
using namespace std;
/*Домашнее задание. Написать программу, которая выводит на экран прямоугольник символом *.
Высота и ширина задаётся пользователем.*/

int main()
{
    setlocale(LC_ALL, "Russian");
    int height, width;
    cout << "Введите ширину прямоугольника и высоту через пробел:" << endl;
    cin >> width >> height;

    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
        {
            cout << "*";
        }
        cout << endl;
    }
    
    cout << endl;
    return 0;
}


###### Урок #25 - Что такое массив. Примеры. Теория. Array. Одномерный массив. Синтаксис. C++. 
#include <iostream>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    int arr[4];

    arr[0] = 5;
    arr[3] = 3333;
    arr[1] = 7;
    arr[2] = 10;
    
    for (int i = 0; i < 10; i++)   // Пробежимся в том числе и по несуществующим элементам массива
        cout << arr[i] << endl;

    cout << arr[0] << endl;
    return 0;
}


###### Урок #26 - Инициализация массива. Способы. Инициализация массива нулями. C++ для начинающих. 
#include <iostream>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    int arr[5]{};   // заполнить массив из 5 элементов нулями

    cout << arr[3] << endl;

    return 0;
}


###### Урок #27 - Вывод массива. Массивы и циклы. Цикл с массивом. Array c++. C++ для начинающих. 
#include <iostream>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    const int SIZE = 10;
    int arr[SIZE];

    for (int i = 0; i < SIZE; i++)
    {
        arr[i] = i;
    }

    for (int i = 0; i < SIZE; i++)
    {
        cout << arr[i] << endl;
    }
    
    return 0;
}


###### Урок #28 - sizeof что это. sizeof c++ массив. Узнать количество элементов массива. sizeof array.
#include <iostream>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    
    int arr[]{5,33,545,111,326, 1212,223};

    //cout << sizeof(double) << endl << endl;
    
    for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        cout << arr[i] << endl;
    }
    
    return 0;
}


###### Урок #29 - rand. srand. rand задать диапазон. srand time null. Генератора случайных чисел. randomize.
#include <iostream>
#include <ctime>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    srand(time(NULL));
    
    int const SIZE = 10;
    int arr[SIZE];

    for (int i = 0; i < SIZE; i++)
    {
        arr[i] = rand() % 10;
    }

    for (int i = 0; i < SIZE; i++)
    {
        cout << "arr[" << i << "] - " << arr[i] << endl;
    }
           
    return 0;
}


###### Домашнее задание #7 - Заполнить массив случайными числами. Генератор уникальных случайных чисел. rand. srand (МОЁ РЕШЕНИЕ)
/*Домашнее задание #7 - Заполнить массив случайными 
числами. Генератор уникальных случайных чисел. rand. */
#include <iostream>
#include <ctime>

using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    srand(time(NULL));

    const int SIZE = 30;
    int arr[SIZE]{};     // инициализация массива нулями
    int tmp, count;

    for (int i = 0; i < SIZE; i++)
    {
        while (true)
        {
            count = 0;
            tmp = rand() % 100;

            for (int j = 0; j < i; j++)
            {
                if (arr[j] == tmp)
                {
                    count++;
                    cout << "[WARNING!] Повторный элемент - " << tmp << endl;
                }
            }

            if (count == 0)     // если повторяющихся элементов нет
                break;          // выходит из цикла проверки
        }
        arr[i] = tmp;
    }

    cout << "Результат: ";
    for (int i = 0; i < SIZE; i++)
    {
        cout << arr[i] << " ";
    }

    cout << endl;
    return 0;
}


###### Домашнее задание #7 - Заполнить массив случайными числами. Генератор уникальных случайных чисел. rand. srand (РЕШЕНИЕ АВТОРА)
// https://youtu.be/cLzJxOwLSB0
#include <iostream>
#include <ctime>

using namespace std;

/*Домашнее задание #7 - Заполнить массив случайными 
числами. Генератор уникальных случайных чисел. rand. */

int main()
{
    setlocale(LC_ALL, "Russian");
    srand(time(NULL));

    const int SIZE = 10;
    int arr[SIZE]; 
    bool alreadyThere;      // флаг
    
    for (int i = 0; i < SIZE; )
    {
        alreadyThere = false;
        int newRandomValue = rand() % 20;
        
        for (int j = 0; j < i; j++)
        {
            if (arr[j] == newRandomValue)
            {
                alreadyThere = true;
                break;
            }
        }

        if (!alreadyThere)
        {
            arr[i] = newRandomValue;
            i++;
        }
    }

    for (int i = 0; i < SIZE; i++)
    {
        cout << arr[i] << " ";             // вывод готового массива на экран
    }

    cout << endl;
    return 0;
}


###### Домашнее задание #8 - Найти минимальный элемент массива. Поиск минимального элемента в массиве. C++ для начинающих
/*Домашнее задание #8 - Заполнить массив случайными
числами. Найти минимальный элемент массива. */

#include <iostream>
#include <ctime>
using namespace std;

int main() 
{
    setlocale(LC_ALL, "Russian");
    srand(time(NULL));

    const int SIZE = 10;
    int arr[SIZE];
    bool alreadyThere;
    int minValue;
    
    for (int i = 0; i < SIZE; )
    {
        alreadyThere = false;
        int randValue = rand() % 20;

        for (int j = 0; j < i; j++)
        {
            if (randValue == arr[j])
            {
                alreadyThere = true;
                break;
            }
        }

        if (!alreadyThere)
        {
            arr[i] = randValue;
            i++;
        }
    }

    for (int i = 0; i < SIZE; i++)
    {
        cout << arr[i] << " ";
    }
    cout << endl;

    minValue = arr[0];
    for (int i = 1; i < SIZE; i++)
    {
        if (arr[i] < minValue)
        {
            minValue = arr[i];
        }
    }
    
    cout << endl << "Минимальный элемент массива равен " << minValue << endl;

    cout << endl;
    return 0;
}


###### Урок #31 - Двумерный массив инициализация. Двумерный массив индексы. Синтаксис. Пример.
#include <iostream>
#include <ctime>
using namespace std;

int main() 
{
    setlocale(LC_ALL, "russian");
    const int ROW = 3;
    const int COL = 4;

    // int arr[][COL]{} 

    int arr[ROW][COL]
    { 
        {2,4,55,1},
        {22,34,545,21},
        {2,3,45,22} 
    };

    cout << arr[1][1] << endl;

    cout << endl;
    return 0;
}


###### Урок #31 - Двумерные массивы вывод. Заполнение. Двумерный массив циклы. C++ для начинающих.
#include <iostream>
#include <ctime>
using namespace std;

int main() 
{
    setlocale(LC_ALL, "russian");
    srand(time(NULL));

    const int ROWS = 5;
    const int COLS = 8;

    int arr[ROWS][COLS];

    for (int i = 0; i < ROWS; i++)
    {
        for (int j = 0; j < COLS; j++)
        {
            arr[i][j] = rand() % 10;
        }
    }

    for (int i = 0; i < ROWS; i++)
    {
        for (int j = 0; j < COLS; j++)
        {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}


###### Урок #33 - Функции c++ примеры. Синтаксис. Объявление, реализация функции. Параметры, аргументы.
#include <iostream>
using namespace std;

void foo()
{
    cout << "Я функция, меня вызвали!" << endl;
    return;   // default
}

int Sum(int a, int b)
{
    return a + b;
}

int main() 
{
    setlocale(LC_ALL, "russian");

    int c;
    int q = 11;
    int w = 12;

    cout << Sum(q, w) << endl;
    foo();

    return 0;
}


###### Урок #34 - Передача параметров в функцию по значению. Параметры функции. Передача аргументов в функцию.
#include <iostream>
using namespace std;

int Foo(int a)
{
    return ++a;      // Префиксный инкримент - самый высокий приоритет
}

int main() 
{
    setlocale(LC_ALL, "russian");
    int value = 1;

    value = Foo(value);

    cout << value << endl;
    return 0;
}


###### Урок #35 - Передача массива в функцию. Как передать массив в функцию. C++ для начинающих.
#include <iostream>
using namespace std;

void FillArray(int arr[], const int size)
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 10;
    }
}

void PrintArray(int arr[], const int size)
{
    for (int i = 0; i < size; i++)
    {
        cout << arr[i] << endl;
    }
}

int main() 
{
    setlocale(LC_ALL, "russian");
    const int SIZE = 10;
    int massiv[SIZE];

    int a = sizeof(massiv);

    FillArray(massiv, SIZE);

    PrintArray(massiv, SIZE);

    return 0;
}


###### Урок #36 - Прототипы функций. Прототип функции что это. Прототип функции пример. C++ для начинающих.
#include <iostream>
using namespace std;

int foo(int a, int b);     // прототип функции

int main() 
{
    setlocale(LC_ALL, "russian");
    // foo(5, 6);
    cout << foo(5, 6) << endl;

    return 0;
}

int foo(int a, int b)
{
    cout << "Я функция, меня вызвали!" << endl;
    return a + b;
}


###### Урок #37 - Область видимости. Глобальные переменные и локальные переменные. C++ для начинающих.
#include <iostream>
using namespace std;

int a;     // глобальные переменные инициализируются НЕ МУСОРОМ, а значением по умолчанию

void foo(int a)    // в таком случае переменная a - ЛОКАЛЬНАЯ, а НЕ ГЛОБАЛЬНАЯ
{
    a++;
}

void main() 
{
    a++;      // а - ГЛОБАЛЬНАЯ переменная
    foo();
    cout << a << endl;
}


###### Урок #38 - Параметры по умолчанию. Передача аргументов в функцию по умолчанию. Аргументы по умолчанию.
#include <iostream>
using namespace std;

void foo(int a = 5, double b = 0.5)
{
    for (int i = 0; i < a; i++)
    {
        cout << "#" << endl;
    }
    cout << b * 100 << endl;
}

void main() 
{
    foo(10, 0.7);
    foo();
}


###### Урок #39 - inline c++ что это. Ключевое слово inline. Встраиваемая функция. C++ для начинающих.
#include <iostream>
using namespace std;

inline int Sum(int a, int b)    // используется только для маленьких простых функций
{
    return a + b;
}

void main() 
{
    Sum(3, 4);
}


###### Урок #40 - Перегрузка функций c++ пример.Что такое перегрузка функций. Как перегрузить функцию. 
#include <iostream>
using namespace std;

int Sum(int a, int b)
{
    return a + b;
}

int Sum(int a, int b, int c)
{
    a++;
    cout << "TEST" << endl;
    return a + b + c;
}

double Sum(double a, double b)
{
    return a + b;
}

void main() 
{
    cout << Sum(7.321, 12.3216) << endl;   // double Sum(double a, double b)
    cout << Sum(10, 2) << endl;            // int Sum(int a, int b)
    cout << Sum(10, 1, 5000) << endl;      // int Sum(int a, int b, int c)
}


###### Урок #41 - Шаблоны функций. Шаблонные функции c++. template typename. template class. 
#include <iostream>
using namespace std;

/*
template <typename T>

T Sum(T a, T b)
{
    return a + b;
}

template <typename T1, typename T2>

T1 Sum(T1 a, T2 b)
{
    return a + b;
}

template <typename T1, typename T2>

void Sum(T1 a, T2 b)
{
    cout << a << endl;
    cout << b << endl;
}
*/

template <class T>         // то же самое, что и "template <typename T>"
void Sum(T a)
{
    cout << a << endl;
}

void main() 
{
    setlocale(LC_ALL, "Russian");
    Sum(10);
    Sum(9.23324);
    Sum("asass");
}


###### Урок #42 - Функции и стек. Стек алгоритм. Стек что это. Стек рекурсии. Стек c++. Стек рекурсивных вызовов


###### Урок #43 - Рекурсия что это. Рекурсия программирование. Рекурсия и цикл. Рекурсия с++. Для начинающих.
#include <iostream>
using namespace std;

int Foo(int a)
{
    if (a < 1)
        return 0;
    a--;
    cout << a << endl;
    return Foo(a);
}

void main() 
{
    setlocale(LC_ALL, "Russian");

    cout << "RESULT: " << Foo(5) << endl;
}


###### Урок #44 - Рекурсия. Факториал числа c++ рекурсивно. Рекурсия факториал. Рекурсивный алгоритм факториал.
#include <iostream>
using namespace std;

// Факториал: N! = N * (N-1)!; 

int Fact(int N)
{
    if (N < 0)
    {
        return 0;
    }
    
    if (N == 0 || N == 1)
    {
        return 1;
    }
    return N * Fact(N - 1);
}

void main() 
{
    setlocale(LC_ALL, "Russian");
    
    cout << Fact(5) << endl;

/*  for (int i = 0; i < 10; i++)
    {
        cout << "Factorial " << i << " = " << Fact(i) << endl;
    }   */
}


###### Урок #45 - Что такое динамическая память. Утечка памяти. Стек и куча. Статическая память. Обзорный урок


###### Урок #46 - Указатели c++ что это. Для чего нужны. Указатели c++ разыменование. C++ для начинающих.
#include <iostream>
using namespace std;


void main() 
{
    int a = 5;
    cout << "a\t" << a << endl;

    int *pa = &a;      // указатель 'pa' на переменную 'a'. & - оператор взятия адреса в RAM
    int *pa2 = &a;
    
    cout << "pa\t" << pa << "\npa2\t" << pa2 << endl;
    cout << "*pa\t" << *pa << endl;      // *pa - РАЗЫМЕНОВАНИЕ указателя = получение значения по адресу в RAM

    *pa2 = 2;      // присвоение значения через указатель через РАЗЫМЕНОВЫВАНИЕ
    cout << "a\t" << a << endl;
    cout << "*pa\t" << *pa << endl;
}


###### Урок #47 - Арифметика указателей. Указатели и массивы. Массив это указатель. C++ для начинающих.
#include <iostream>
using namespace std;

void main() 
{
    const int SIZE = 5;
    int arr[SIZE]{4,55,79,1,4};       // имя массива - это УКАЗАТЕЛЬ на его первый элемент - arr[0]
    int *pArr = arr;
    
    cout << *(arr + 1) << endl;     // сдвиг на 1 шаг, равный количеству байт типа элементов массива
                                    // в нашем случае - int - 4 байта

    for (int i = 0; i < SIZE; i++)
    {
        cout << (arr + i) << "\t" << *(arr + i) << endl;
    }

    cout << *(arr + 10) << endl;     // ОПАСНО!!! МЫ МОЖЕМ ВЫХОДИТЬ ЗА ГРАНИЦЫ МАССИВА
/*
    for (int i = 0; i < SIZE; i++)
    {
        cout << arr[i] << endl;
    }

    cout << "=========================" << endl;

    cout << "arr\t" << arr << endl;
    cout << "pArr\t" << pArr << endl;

    cout << "=========================" << endl;

    for (int i = 0; i < SIZE; i++)
    {
        cout << *(pArr + i) << endl;        // эквивалентно - pArr[i] 
    }
*/
}


###### Урок #48 - Передача параметров в функцию по указателю c++. Передача указателя в функцию си.
#include <iostream>
using namespace std;

void Foo(int *pa)     // аргумент - УКАЗАТЕЛЬ
{
    (*pa)++;      // СНАЧАЛА - разыменовать, а потом увеличить значение на 1. 
                  // Тут идёт работа непосредственно с памятью. Поэтому все измененения
                  // сохраняются в ячейках памяти
}

void main() 
{
    int a = 0;
    cout << a << endl;

    Foo(&a);         // передаём АДРЕС
    cout << a << endl;

}


###### Урок #49 - Возврат нескольких значений функции через указатели. Функция возвращает несколько значений.
#include <iostream>
using namespace std;

void Foo(int *pa, int *pb, int *pc)
{
    (*pa) = 555;
    (*pb)++;
    (*pc) = -20;
}

void main() 
{
    int a = 0, b = 0, c = 1;

    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
    cout << "c = " << c << endl;

    cout << "foo" << endl;

    Foo(&a, &b, &c);      

    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
    cout << "c = " << c << endl;

}


###### Домашнее задание #9 - Напишите функцию, меняющую местами значения переменных с помощью указателей.
/*Домашнее задание #9 - 
Напишите функцию, меняющую местами 
значения переменных с помощью указателей.*/

#include <iostream>
using namespace std;

void Swap(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

void main() 
{
    setlocale(LC_ALL, "Russian");
    int var1, var2;

    cout << "Введите два целых числа через пробел:" << endl;
    cin >> var1 >> var2;

    cout << "var1\t" << var1 << endl;
    cout << "var2\t" << var2 << endl;
    cout << "Swap" << endl;

    Swap(&var1, &var2);

    cout << "var1\t" << var1 << endl;
    cout << "var2\t" << var2 << endl;
    
}


###### Урок #50 - c++ ссылки что это. c++ ссылки и указатели разница. Указатель на ссылку. 
#include <iostream>
using namespace std;


void main() 
{
    setlocale(LC_ALL, "Russian");
    int a = 5;
    
    int *pa = &a;     // запись адреса переменной В УКАЗАТЕЛЬ

    int &aRef = a;    // запись адреса переменной В ССЫЛКУ 

    int *ppa = &aRef;

    cout << "a\t" << a << endl;
    *ppa = 12;
    cout << "a\t" << a << endl;

/*
    cout << "*pa\t" << pa << endl;
    pa++;                                  // АРИФМЕТИКА указателей
    cout << "*pa\t" << pa << endl;

    aRef = 55;
    cout << "a\t" << a << endl;
                                           
    cout << "*pa\t" << *pa << endl;
    cout << "&aRef\t" << aRef << endl;

    int *pp = NULL;    
    // int *pp = nullptr;
*/
}


###### Урок #51 - Передача параметров в функцию по ссылке. Разница между ссылкой и указателем.
#include <iostream>
using namespace std;

void Foo(int a)
{
    a = 1;
}

void Foo2(int &a)
{
    a = 2;
}

void Foo3(int *a)
{
    *a = 3;
}

void main() 
{
    int value = 5;
    cout << "value = " << value << endl << endl;

    Foo(value);
    cout << "Foo = " << endl;
    cout << "value = " << value << endl << endl;

    Foo2(value);
    cout << "Foo2 = " << endl;
    cout << "value = " << value << endl << endl;

    Foo3(&value);
    cout << "Foo3 = " << endl;
    cout << "value = " << value << endl << endl;

}


###### Урок #52 - Возврат нескольких значений функции через ссылки. Как вернуть несколько значений функции.
#include <iostream>
using namespace std;

void Foo(int &a, int &b, int &c)
{
    a = 10;
    b *= 2;
    c -= 100;
}

void main() 
{
    int a = 0, b = 4, c = 34;
    cout << "a = " << a <<endl;
    cout << "b = " << b << endl;
    cout << "c = " << c << endl;

    cout << "Foo" << endl;
    Foo(a, b, c);

    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
    cout << "c = " << c << endl;

}


###### Домашнее задание #10 - написать ШАБЛОННУЮ функцию которая меняет местами значения 2-х переменных с помощью ССЫЛОК.
#include <iostream>
#include <string>
using namespace std;

template <typename T>
void Swap(T &a, T &b)
{
    T temp = a;
    a = b;
    b = temp;
}


void main()
{
    int a1 = 10, a2 = 20;
    double b1 = 1.23, b2 = 4.56;
    char c1 = 'A', c2 = 'Z';
    string s1 = "string1", s2 = "STRING2";

    cout << "(a1, a2) = (" << a1 << ", " << a2 << ")" << endl;
    cout << "Swap" << endl;
    Swap(a1, a2);
    cout << "(a1, a2) = (" << a1 << ", " << a2 << ")" << endl << endl;

    cout << "(b1, b2) = (" << b1 << ", " << b2 << ")" << endl;
    cout << "Swap" << endl;
    Swap(b1, b2);
    cout << "(b1, b2) = (" << b1 << ", " << b2 << ")" << endl << endl;

    cout << "(c1, c2) = (" << c1 << ", " << c2 << ")" << endl;
    cout << "Swap" << endl;
    Swap(c1, c2);
    cout << "(c1,c2) = (" << c1 << ", " << c2 << ")" << endl << endl;

    cout << "(s1, s2) = (" << s1 << ", " << s2 << ")" << endl;
    cout << "Swap" << endl;
    Swap(s1, s2);
    cout << "(s1,s2) = (" << s1 << ", " << s2 << ")" << endl << endl;

}


###### Урок #53 - new c++ что это. new c++ пример. c++ new delete. delete c++ что это. delete c++ пример.
#include <iostream>
using namespace std;


void main()
{
    int *pa = new int;    // выдялет место в RAM за пределами нашей программы
    *pa = 10;
    cout << *pa << endl;
    cout << pa << endl;
    
    delete pa;           // ОБЯЗАТЕЛЬНО!!! Очистить за собой место в RAM
     
    cout << pa << endl;
}


###### Урок #54 - Что такое null pointer. null c++ что это. nullptr c++ что это. nullptr c++11.
#include <iostream>
using namespace std;


void main()
{
    int *pa = new int;
    *pa = 10;
    cout << *pa << endl;
    delete pa;   // СНАЧАЛА зачистить данные из RAM, а только потом обнулять указатель - nullptr

    //pa = 0;     // нулевой указатель. 
    //pa = NULL;  // то же самое, что "pa = 0;"
    pa = nullptr;   // НЕ ЦЕЛОЧИСЛЕННЫЙ НОЛЬ (int 0) !!!  <--- BEST PRACTICE

    if (pa != nullptr)
    {
        cout << pa << endl;
    }
    
}


###### Урок #55 - Динамический массив с++ пример. Создание, заполнение, удаление, размер динамического массива.
#include <iostream>
using namespace std;

void main() 
{
    setlocale(LC_ALL, "Rus");
    int size = 0;            // лучше, чтобы это была не константа!!!
    cout << "Enter an array size: ";
    cin >> size;            // размер можно задать с STDIN
    int *arr = new int[size];     // динамический массив

    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 10;
    }

    for (int i = 0; i < size; i++)
    {
        cout << arr[i] << "\t";
        cout << *(arr + i) << "\t";
        cout << arr + i << endl;
    }

    delete [] arr;           // указываем сразу !!!

}


###### Урок #56 - Двумерный динамический массив c++ пример. Создание, заполнение, удаление. Динамические массивы.
#include <iostream>
using namespace std;

void main() 
{
    int rows;
    int cols;

    cout << "Entre ROWS and COLS: " << endl;
    cin >> rows >> cols;

    int **arr = new int* [rows];
    
    for (int i = 0; i < rows; i++)
    {
        arr[i] = new int[cols];
    }
    ///////////////////////////////////////////

    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            arr[i][j] = rand() % 20;
        }
    }

    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            cout << arr[i][j] << "\t";
        }
        cout << endl;
    }
    ///////////////////////////////////////////
    for (int i = 0; i < rows; i++)    
    {
        delete[] arr[i];              // !!! clear RAM
    }
    delete[] arr;                     // !!! clear RAM
}


###### Урок #57 - Константные аргументы функции. Константный указатель. Константные параметры.
#include <iostream>
using namespace std;

void FillArray(int* const arr, const int size)     // ФИЧА!!! const - для удобства и фиксации
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 10;
    }
}

void ShowArray(int* const arr, const int size)
{
    for (int i = 0; i < size; i++)
    {
        cout << arr[i] << "\t";
    }
    cout << endl;
}

void main() 
{
    const int size = 10;
    int arr[size];
    FillArray(arr, size);
    ShowArray(arr, size);
}


###### Урок #58 - Копирование динамического массива c++. Скопировать массив с++.
#include <iostream>
using namespace std;

void FillArray(int* const arr, const int size)     // ФИЧА!!! const - для удобства и фиксации
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 10;
    }
}

void ShowArray(int* const arr, const int size)
{
    for (int i = 0; i < size; i++)
    {
        cout << arr[i] << "\t";
    }
    cout << endl;
}

void main() 
{
    int size = 10;
    int* firstArray = new int[size];
    int* secondArray = new int[size];


    FillArray(firstArray, size);
    FillArray(secondArray, size);

    cout << "firstArray =\t";
    ShowArray(firstArray, size);
    cout << "secondArray =\t";
    ShowArray(secondArray, size);

    // ПРАВИЛЬНОЕ КОПИРОВАНИЕ:
    delete[] firstArray;                    // 1 - УДАЛИТЬ МАССИВ

    firstArray = new int [size];            // 2 - ОБЪЯВЛЯЕМ НОВЫЙ динамический массив размером копируемого массива (secondArray)

    for (int i = 0; i < size; i++)          // 3 - КОПИРУЕМ ПОЭЛЕМЕНТНО
    {
        firstArray[i] = secondArray[i];     
    }
    // ПОЛУЧИЛИ 2 РАЗНЫХ массива с одинаковыми элементами

    cout << "==========================================" << endl;

    cout << "firstArray =\t";
    ShowArray(firstArray, size);
    cout << "secondArray =\t";
    ShowArray(secondArray, size);

    delete[] firstArray;
    delete[] secondArray;
}


###### Урок #59 - Изменить размер массива. Удалить. Добавить элемент в массив. Увеличение массива. с++
#include <iostream>
using namespace std;

void FillArray(int* const arr, const int size)         // Заполнить массив случаными числами от 0 до 10
{
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 10;
    }
}

void ShowArray(const int* const arr, const int size)    // вывести элементы массива на экран
{
    for (int i = 0; i < size; i++)
    {
        cout << arr[i] << "\t";
    }
    cout << endl;
}

void push_back(int*& arr, int& size, const int value)      // добавить элемент в конец массива (*& - ссылка на указатель массива)
{
    int* newArray = new int[size + 1];

    for (int i = 0; i < size; i++)
    {
        newArray[i] = arr[i];
    }

    newArray[size] = value;
    size++;

    delete[] arr;
    arr = newArray;
}

void pop_back(int*& arr, int& size)        // удалить последний элемент
{
    size--;
    int* newArray = new int[size];

    for (int i = 0; i < size; i++)
    {
        newArray[i] = arr[i];
    }

    delete[] arr;
    arr = newArray;
}

void push_front(int*& arr, int& size, const int value)      // добавить элемент в начало массива
{
    int* newArray = new int[size + 1];

    for (int i = 0; i < size; i++)
    {
        newArray[i + 1] = arr[i];
    }

    newArray[0] = value;
    size++;

    delete[] arr;
    arr = newArray;
}

void pop_front(int*& arr, int& size)        // удалить самый первый элемент
{
    size--;
    int* newArray = new int[size];

    for (int i = 0; i < size; i++)
    {
        newArray[i] = arr[i+1];
    }

    delete[] arr;
    arr = newArray;
}

void push_index(int *&arr, int &size, const int index, const int value)      // ДОБАВИТЬ элемент в ПО ИНДЕКСУ
{
    int* newArray = new int[size + 1];

    if (index > size || index < 0)         // Защита от неправильного ввода индекса
    {
        cout << endl << "[ERROR!!!] Invalid index value (" << index << ")" << endl;
        return;
    }
    
    if (index == 0)                       // Вставка в начало массива (индекс = 0)
    {
        for (int i = 0; i < size; i++)
        {
            newArray[i+1] = arr[i];
        }
        newArray[0] = value;
    }
    else if (index == size)                    // вставка в конец массива (индекс = size)
    {
        for (int i = 0; i < size; i++)
        {
            newArray[i] = arr[i];
        }
        newArray[size] = value;
    }
    else
    {
        for (int i = 0; i < index; i++)
        {
            newArray[i] = arr[i];
        }
        newArray[index] = value;
        for (int i = index; i < size; i++)
        {
            newArray[i+1] = arr[i];
        }
    }

    size++;
    delete[] arr;
    arr = newArray;
}

void pop_index(int*& arr, int& size, const int index)      // УДАЛИТЬ элемент в ПО ИНДЕКСУ
{
    int* newArray = new int[size - 1];

    if (index >= size || index < 0)         // Защита от неправильного ввода индекса
    {
        cout << endl << "[ERROR!!!] Invalid index value (" << index << ")" << endl;
        return;
    }

    if (index == 0)                       // Удаление первого элемента массива (индекс = 0)
    {
        for (int i = 0; i < (size - 1); i++)
        {
            newArray[i] = arr[i+1];
        }
    }
    else if (index == (size - 1))                    // Удаление последнего элемента массива (индекс = size)
    {
        for (int i = 0; i < (size - 1); i++)
        {
            newArray[i] = arr[i];
        }
    }
    else
    {
        for (int i = 0; i < index; i++)
        {
            newArray[i] = arr[i];
        }

        for (int i = index; i < (size - 1); i++)
        {
            newArray[i] = arr[i+1];
        }
    }

    size--;
    delete[] arr;
    arr = newArray;
}



void main()
{
    int size = 5;
    int* arr = new int[size];
    int temp = 1111;

    FillArray(arr, size);
    ShowArray(arr, size);
    cout << "===================================================" << endl;

    push_back(arr, size, temp);
    ShowArray(arr, size);
    pop_back(arr, size);
    ShowArray(arr, size);
    cout << "===================================================" << endl;
    
    push_front(arr, size, temp);
    ShowArray(arr, size);
    pop_front(arr, size);
    ShowArray(arr, size); 
    cout << "===================================================" << endl;

    push_index(arr, size, 5, temp);
    ShowArray(arr, size);
    pop_index(arr, size, 5);
    ShowArray(arr, size);
    cout << "===================================================" << endl;

    push_index(arr, size, 0, temp);
    ShowArray(arr, size);
    pop_index(arr, size, 0);
    ShowArray(arr, size);
    cout << "===================================================" << endl;

    push_index(arr, size, 2, temp);
    ShowArray(arr, size);
    pop_index(arr, size, 2);
    ShowArray(arr, size);
    cout << "===================================================" << endl;

    push_index(arr, size, -1, temp);
    ShowArray(arr, size);
    push_index(arr, size, 50, temp);
    ShowArray(arr, size);

    cout << "===================================================" << endl;

    delete[] arr;
}


###### Урок #60 - Строки в с++. Нуль терминатор. Что такое строка в с++. char c++ массив. С++ Для начинающих.
#include <iostream>
using namespace std;

void main()
{
    // char string[] = "Hello World!";
    char string[] = {'H', 'e', 'l', 'l', 'o', '\0'};
    // char string[] = { 'H', 'e', 'l', 'l', 'o'};
    cout << strlen(string) << endl;
}


###### Урок #61 - Приведение типов в стиле с. Явное и неявное преобразование типов. Преобразование типов. С++
#include <iostream>
using namespace std;

void main()
{
    double a = 33.3;

    int b = 34.355445;         // неявное преобразование типов (будет int). В данном случае - сужающее - убирается часть числа
    int b = a; 

    cout << (int)a << endl;    // явное преобразование типов
    cout << (bool)a << endl;
    cout << (char)a << endl;
}


###### Урок #62 - Что такое ascii символы. ascii что это такое? Таблица ascii c++. C ++ Для начинающих.
#include <iostream>
using namespace std;

void main()
{
    setlocale(LC_ALL, "Rus");
    //cout << sizeof(char) << endl;

    for (int i = 0; i < 256; i++)
    {
        cout << "code = " << i << "\tchar = " << (char)i << endl;
    }
}


###### Урок #63 - Указатели символьные строки и функции. Строки и указатели в c++. C ++ Для начинающих.
#include <iostream>
using namespace std;

void foo(char* str)
{
    cout << strlen(str);
}

void main()
{
    char string[] = "Hello!";
    // char *str1 = string;
    // const char *str2 = "Hello!"; 
    //const char* strArr[] = {"Hello", "World", "TEST"};

    /*
    for (int i = 0; i < 3; i++)
    {
        cout << strArr[i] << endl;
    }
    */
    foo(string);

}


###### Домашнее задание #11 - strlen c++ реализация. Посчитать количество символов в строке c++
#include <iostream>
using namespace std;

int Strlen(const char* str)
{
    int count = 0;
    while (str[count] != '\0')
        count++;

    return count;
}

void main()
{
    //char string[] = "Hello!";

    char str[] = {'H', 'e', 'l', 'l', 'o', '\0'};

    cout << Strlen(str) << endl;
}


###### Урок #64 - Конкатенация строк что это. Объединение строк.Тип данных string c++ что это.
#define _CRT_SECURE_NO_WARNINGS    // Для стиля Си
#include <iostream>
#include <string>
using namespace std;


void main()
{
    /*
    ////////////////// Конкатенация в стиле Си: //////////////////
    char result[255]{};      // инициализируем симовлами '\0'
    char str1[255] = "Hello";
    char str2[255] = "World";

    cout << str1 << endl;
    strcat(result, str1);       
    strcat(result, str2);
    cout << result << endl;
    */
    
    string str1 = "Ivan";
    string str2 = "Sergeevich";
    string str3 = "Golovlev";
    string result;

    result = "Surname:\t" + str3 + "\nName:\t\t" + str1 + "\nSecond Name:\t" + str2;
    cout << result << endl;
}


###### Урок #65 - Указатель на функцию в качестве параметра. Передача функции в качестве параметра. С++
#include <iostream>
#include <string>
using namespace std;

// тип функции(*имя указателя)(спецификация параметров);

string GetDataFromAstral()
{
    return "Data From Astral";
}

string GetDataFromDB()
{
    return "Data From DB";
}

string GetDataFromWebServer()
{
    return "Data From Web Server";
}

void ShowInfo(string (*foo)())
{
    cout << foo() << endl ;
}

void main()
{
    /* int (*fooPointer)(int a);
    fooPointer = Foo1;  
    cout << Foo1(2) << endl;*/
    ShowInfo(GetDataFromDB);
    ShowInfo(GetDataFromWebServer);
    ShowInfo(GetDataFromAstral);
}


###### Урок #66 - Препроцессор что это. Директива #define. Макросы. Директивы препроцессора что это. C++
#include <iostream>
#define PI 3.14
#define tab "\t"
#define begin {
#define end }

using namespace std;

void main()
{
    //cout << "text" << tab << "text" << endl;
    for (int i = 0; i < 5; i++)
        begin
            cout << i << endl;
        end
}


###### Урок #67 - c++ макрос функция. Макросы с аргументами. Макрос с параметрами. C ++ Для начинающих.
#include <iostream>
#define FOO(x, y)((x)*(y))
using namespace std;

void main()
{
    cout << FOO(5, 6) << endl;
}


###### Урок #68 - Условная компиляция. #ifdef #else #endif #if #elif #endif #ifndef что это. C++
#include <iostream>
using namespace std;
#define DEBUG 5


void main()
{
    setlocale(LC_ALL, "rus");

#ifdef DEBUG
    cout << "Начало цикла" << endl;
#endif    // DEBUG

    for (int i = 0; i < 4; i++)
    {
        cout << i << endl;
    }

#ifdef DEBUG
    cout << "Конец цикла" << endl;
#endif    // DEBUG

//////////////////////////////////////////////////////////////

#ifdef DEBUG
    cout << "Дебаг определен " << endl;
#else 
    cout << "Дебаг НЕ определён" << endl;
#endif    // DEBUG

//////////////////////////////////////////////////////////////

#ifndef DEBUG                           // if NO def
    cout << "Дебаг НЕ определен " << endl;
#else 
    cout << "Дебаг определён" << endl;
#endif    // DEBUG

//////////////////////////////////////////////////////////////

#if DEBUG < 4
    cout << "cout 1" << endl;
#elif DEBUG == 5
    cout << "cout 2" << endl;
#else 
    cout << "cout 3" << endl;
#endif    // DEBUG

//////////////////////////////////////////////////////////////
}


###### Урок #69 - Условный тернарный оператор что это. Как работает. Как использовать. C ++ Для начинающих.
#include <iostream>
using namespace std;

void main()
{
    setlocale(LC_ALL, "rus");
    int a;
    cout << "Input int a: " << endl;
    cin >> a;
    
    /*
    if (a < 10)
    {
        cout << "a < 10" << endl;
    }
    else
    {
        if (a > 10)
        {
            cout << "a > 10" << endl;
        }
        else
        {
            cout << "a == 10" << endl;
        }
    }
    */

    // (a < 10) ? (cout << "a < 10" << endl) : (cout << "a > 10" << endl);    // тернарный оператор. Можно без скобок!!!
    // (a < 10) ? (a += 10) : (a++);
    (a < 10) ? (cout << "a < 10" << endl) : (a > 10) ? (cout << "a > 10" << endl) : (cout << "a == 10" << endl);
}


###### Урок #70 - argc argv c++ что это. Параметры функции main argc argv. Аргументы main.
#include <iostream>
using namespace std;

void main(int argc, char *argv[])
{
    cout << argc << endl;
    
    for (int i = 0; i < argc; i++)
    {
        cout << argv[i] << endl;
    }
    system("pause");
}


###### Урок #71 - int main или void main. int main vs void main c++. C ++ Для начинающих.
#include <iostream>
using namespace std;

int main(int argc, char *argv[])
{

    return 0;
}


###### Урок #72 - Что такое ООП простыми словами. Объектно ориентированное программирование это


###### Урок #73 - Что такое класс. Что такое объект класса. Экземпляр класса это. Класс ООП это.
#include <iostream>
#include <string>
using namespace std;


class Human          // класс - пользовательский тип данных
{
public:              // модификатор доступа
    int age;         // свойства класса (содержат характеристику класса) - это ПОЛЯ КЛАССА
    string name;
    int weight;
};

class Point
{
public:
    int x;
    int y;
    int z;
};

int main() 
{
    /*
    Human firstHuman;        // создаём объект класса Human
    firstHuman.age = 19;
    firstHuman.name = "Ivanov Ivan Ivanovich";
    firstHuman.weight = 89;

    cout << firstHuman.age << endl;
    cout << firstHuman.name << endl;
    cout << firstHuman.weight << endl;

    cout << "_________________________________" << endl;
    Human secondHuman;
    secondHuman.age = 30;
    secondHuman.name = "Nonanme";
    secondHuman.weight = 73;

    cout << secondHuman.age << endl;
    cout << secondHuman.name << endl;
    cout << secondHuman.weight << endl;
    */
    Point a;
    a.x = 1;
    a.y = 3;
    a.z = 5;

    return 0;
}


###### Урок #74 - Методы класса. Что такое методы в программировании. Вызов метода класса. Функции. C++
#include <iostream>
#include <string>
using namespace std;


class Human          
{
public:              
    int age;         
    int weight;
    string name;

    void Print()
    {
        cout << "Имя\t" << name << "\nВес\t" << weight << "\nВозраст\t" << age << endl << endl;
    }
};

class Point
{
public:
    int x;
    int y;
    int z;
};

int main() 
{
    setlocale(LC_ALL, "ru");

    Human firstHuman;
    firstHuman.age = 30;
    firstHuman.name = "Ivanov Ivan";
    firstHuman.weight = 100;
    firstHuman.Print();
    
    Human secondHuman;
    secondHuman.age = 19;
    secondHuman.name = "Tolya";
    secondHuman.weight = 60;
    secondHuman.Print();
    return 0;
}


###### Урок #75 - Модификаторы доступа классов. public private protected что это. Спецификаторы доступа. C++
#include <iostream>
#include <string>
using namespace std;


class Human          
{
public:              
    int age;         
    int weight;
    string name;

    void Print()
    {
        cout << "Имя\t" << name << "\nВес\t" << weight << "\nВозраст\t" << age << endl << endl;
    }
};

class Point
{
private:                        // private - модификатор доступа по умолчанию
    int z;
    void PrintY()
    {
        cout << "PrintY()\t" << y << endl;
    }
public:                         // public - доступно везде
    int x;
    int y;
    void Print()
    {
        cout << "y = " << y << "\nx = " << x << "\nz = " << z << "\nsmth = " << smth << endl;
        PrintY();        // private
    }
protected:                    // играет роль при наследовании
    int smth;


};

int main() 
{
    setlocale(LC_ALL, "ru");

    Point a;
    a.x = 10;
    a.y = 15;
    a.Print();
    return 0;
}


###### Урок #76 - Что такое геттеры и сеттеры для класса. Методы get и set. Инкапсуляция это. Пример. C++ 
#include <iostream>
#include <string>
using namespace std;


class Human          
{
public:              
    int age;         
    int weight;
    string name;

    void Print()
    {
        cout << "Имя\t" << name << "\nВес\t" << weight << "\nВозраст\t" << age << endl << endl;
    }
};

class Point
{
private:
    int x;
    int y;

public:
    void SetX(int valueX)
    {
        x = valueX;
    }
    
    void SetY(int valueY)
    {
        y = valueY;
    }
    
    int GetX()
    {
        return x;
    }

    int GetY()
    {
        return y;
    }

    void Print()
    {
        cout << "X = " << x << "\tY = " << y << endl;
    }
};

int main() 
{
    setlocale(LC_ALL, "ru");

    Point a;
    a.SetX(111111);
    a.SetY(999999999);
    a.Print();

    return 0;
}


###### Урок #77 - Инкапсуляция ООП пример. private методы. Что такое инкапсуляция. C++ Для начинающих.
#include <iostream>
using namespace std;

class CoffeeGrinder
{
private:
    bool CheckVoltage()
    {
        return true;
    }

public:
    void Start()
    {
        if (CheckVoltage())
        {
            cout << "VjuHHH!" << endl;
        }
        else
        {
            cout << "Beep Beep" << endl;
        }
    }

};


int main() 
{
    CoffeeGrinder a;
    a.Start();

    return 0;
}


###### Урок #78 - Конструктор класса пример. Зачем нужен. Конструктор с параметрами. Конструктор по умолчанию.
class Point
{
private:
    int x;
    int y;
public:
    Point(int valueX, int valueY)     // конструктор класса имеет то же имя, что и класс. Область public !!!
    {
        x = valueX;
        y = valueY;
    }

    void SetX(int valueX)
    {
        x = valueX;
    }

    void SetY(int valueY)
    {
        y = valueY;
    }

    int GetX()
    {
        return x;
    }

    int GetY()
    {
        return y;
    }

    void Print()
    {
        cout << "X = " << x << "\tY = " << y << endl << endl;
    }
};

int main() 
{
    Point a(100, 4);
    a.Print();

    Point b(44, 47);
    b.Print();

    return 0;
}


###### Урок #79 - Перегрузка конструкторов класса. Что такое перегрузка. Как перегрузить конструктор.
#include <iostream>
#include <string>
using namespace std;

class Point
{
private:
    int x;
    int y;
public:
    Point()                                // конструктор по умолчанию                          
    {
        x = 0;
        y = 0;
    }

    Point(int valueX, int valueY)          // перегрзука констурктора по умолчанию ( Point() )
    {
        x = valueX;
        y = valueY;
    }

    Point(int valueX, bool boolean)          // перегрзука констурктора по умолчанию ( Point() )
    {
        x = valueX;
        if (boolean)
        {
            y = valueX;
        }
        else
        {
            y = -valueX;
        }
    }
    void SetX(int valueX)
    {
        x = valueX;
    }

    void SetY(int valueY)
    {
        y = valueY;
    }

    int GetX()
    {
        return x;
    }

    int GetY()
    {
        return y;
    }

    void Print()
    {
        cout << "X = " << x << "\tY = " << y << endl << endl;
    }
};


int main() 
{
    Point a;
    a.Print();

    Point b(4, 77);
    b.Print();

    Point c(999, false);
    c.Print();

    return 0;
}


###### Урок #80 - Деструктор что это. Зачем нужен деструктор класса в ООП. Деструктор с параметрами. Перегрузка. 
#include <iostream>
#include <string>
using namespace std;


class MyClass
{  
private:
    int *data;
public:
    MyClass(int size)
    {
        data = new int[size];
    
        for (int i = 0; i < size; i++)
        {
            data[i] = rand() % 10;
        }

        cout << "Object " << data << " Called constructor" << endl;
    }
    
    ~MyClass()                                    // destructor. Может быть в классе лишь один! НЕ МОЖЕТ иметь параметры
    {
        delete[] data;
        cout << "Object " << data << " Called destructor" << endl;
    }

};

void Foo()
{
    cout << "Foo start of implementation" << endl;
    MyClass a(9);
    cout << "Foo end of implementation" << endl;
}

int main() 
{
    MyClass a(11);
    Foo();

    return 0;
}


###### Урок #81 - Ключевое слово this в ООП. Что означает. Что это такое. Для чего нужен this указатель C++
#include <iostream>
using namespace std;


class Point
{
private:
    int x;
    int y;
public:
    Point()                                                    
    {
        x = 0;
        y = 0;
        cout << this << " - constructor" << endl;
    }

    Point(int valueX, int valueY)          
    {
        x = valueX;
        y = valueY;
        cout << this << " - constructor" << endl;
    }

    void SetX(int valueX)
    {
        x = valueX;
    }

    void SetY(int y)
    {
        this->y = y;                         // this->
    }

    int GetX()
    {
        return x;
    }

    int GetY()
    {
        return y;
    }

    void Print()
    {
        cout << "X = " << x << "\tY = " << y << endl << endl;
    }
};


int main() 
{
    Point a;
    a.SetY(5);
    a.Print();

    return 0;
}


###### Урок #82 - Конструктор копирования. Что это. Пример. Когда вызывается Копирование объектов по умолчанию C++
#include <iostream>
#include <string>
using namespace std;

class MyClass
{  
public:
    int *data;

    MyClass(int size)
    {
        this->Size = size;
        this->data = new int [size];

        for (int i = 0; i < size; i++)
        {
            data[i] = i;
        }

        cout << "Called constructor " << this << endl;
    }
    
    MyClass(const MyClass &other)
    {
        this->Size = other.Size;
        
        this->data = new int [other.Size];

        for (int i = 0; i < other.Size; i++)
        {
            this->data[i] = other.data[i];
        }

        cout << "Called copy constructor " << this << endl;
    }

    ~MyClass()                                   
    {
        delete[] data;

        cout << "Called destructor " << this << endl;
    }
private:
    int Size;
};


void Foo(MyClass value)                             // вызывается КОНСТРУКТОР КОПИРОВАНИЯ
{
    cout << "Called function Foo()" << endl;
}

MyClass Foo2()
{
    cout << "Called function Foo2()" << endl;
    MyClass temp(2);
    
    return temp;                                    // вызывается КОНСТРУКТОР КОПИРОВАНИЯ
}

int main() 
{
    MyClass a(10);
    MyClass b(a);                                   // вызывается КОНСТРУКТОР КОПИРОВАНИЯ

    // Foo(a);
    // Foo2();

    return 0;
}


###### Урок #83 - Перегрузка операторов пример. ООП. Перегрузка оператора присваивания. C++ Для начинающих.
#include <iostream>
using namespace std;

class MyClass
{  
public:
    int *data;

    MyClass(int size)
    {
        this->Size = size;
        this->data = new int [size];

        for (int i = 0; i < size; i++)
        {
            data[i] = i;
        }

        cout << "Called constructor " << this << endl;
    }
    
    MyClass(const MyClass &other)
    {
        this->Size = other.Size;
        
        this->data = new int [other.Size];

        for (int i = 0; i < other.Size; i++)
        {
            this->data[i] = other.data[i];
        }

        cout << "Called copy constructor " << this << endl;
    }

    MyClass & operator = (const MyClass &other)                           // Оператор присваивания. Возвращает ССЫЛКУ на this
    {
        cout << "Called operator = " << this << endl;

        this->Size = other.Size;

        if (this->data != nullptr)   
        {
            delete[] this->data;
        }

        this->data = new int[other.Size];

        for (int i = 0; i < other.Size; i++)
        {
            this->data[i] = other.data[i];
        }
        
        return *this;
    }

    ~MyClass()                                   
    {
        delete[] data;

        cout << "Called destructor " << this << endl;
    }
private:
    int Size;
};


int main() 
{
    setlocale(LC_ALL, "ru");

    MyClass a(10);

    MyClass b(2);

    MyClass c(5);

    a = b = c;           // a.operator=(b);

    return 0;
}


###### Урок #84 - Перегрузка оператора равенства == и не равно !=. Перегрузка логических операторов сравнения
#include <iostream>
using namespace std;

class Point
{
private:
    int x;
    int y;

public:
    Point()                                                    
    {
        x = 0;
        y = 0;
        cout << this << " - constructor" << endl;
    }

    Point(int valueX, int valueY)          
    {
        x = valueX;
        y = valueY;
        cout << this << " - constructor" << endl;
    }

    void SetX(int valueX)
    {
        x = valueX;
    }

    void SetY(int y)
    {
        this->y = y;                         // this->
    }

    int GetX()
    {
        return x;
    }

    int GetY()
    {
        return y;
    }

    void Print()
    {
        cout << "X = " << x << "\tY = " << y << endl << endl;
    }

    bool operator == (const Point &other)             // opersator ==
    {
        return this->x == other.x && this->y == other.y;
    }

    bool operator != (const Point &other)            // opersator !=
    {
        return !(this->x == other.x && this->y == other.y);
        // return this->x != other.x || this->y != other.y;
    }
};

int main() 
{
    setlocale(LC_ALL, "ru");

    Point a(15, 11);
    Point b(15, 11);

    a == b ? cout << "a == b" << endl : cout << "a != b" << endl;
    a != b ? cout << "a != b" << endl : cout << "a == b" << endl;

    return 0;
}


###### Урок #85 - Перегрузка оператора сложения. Перегрузка операторов пример.C++ Для начинающих.
#include <iostream>
using namespace std;

class Point
{
private:
    int x;
    int y;

public:
    Point()
    {
        x = 0;
        y = 0;
        cout << this << " - constructor" << endl;
    }

    Point(int valueX, int valueY)
    {
        x = valueX;
        y = valueY;
        cout << this << " - constructor" << endl;
    }

    void SetX(int valueX)
    {
        x = valueX;
    }

    void SetY(int y)
    {
        this->y = y;                         // this->
    }

    int GetX()
    {
        return x;
    }

    int GetY()
    {
        return y;
    }

    void Print()
    {
        cout << "X = " << x << "\tY = " << y << endl << endl;
    }

    bool operator == (const Point& other)             // opersator ==
    {
        return this->x == other.x && this->y == other.y;
    }

    bool operator != (const Point& other)            // opersator !=
    {
        return !(this->x == other.x && this->y == other.y);
        // return this->x != other.x || this->y != other.y;
    }

    Point operator + (const Point& other)
    {
        return Point(this->x + other.x, this->y + other.y);
    }

    void operator += (const Point& other)
    {
        this->x += other.x;
        this->y += other.y;
    }
};

int main()
{
    setlocale(LC_ALL, "ru");

    Point a(15, 11);
    Point b(15, 11);
    Point c;
    c = a + b;
    c.Print();
    a += b;
    a.Print();


    return 0;
}


###### Урок #86 - Перегрузка инкремента и декремента. Постфиксного и префиксного. ООП перегрузка операторов. C++
#include <iostream>
using namespace std;

class Point
{
private:
    int x;
    int y;

public:
    Point()
    {
        x = 0;
        y = 0;
        cout << this << " - constructor" << endl;
    }

    Point(int valueX, int valueY)
    {
        x = valueX;
        y = valueY;
        cout << this << " - constructor" << endl;
    }

    void SetX(int valueX)
    {
        x = valueX;
    }

    void SetY(int y)
    {
        this->y = y;                         // this->
    }

    int GetX()
    {
        return x;
    }

    int GetY()
    {
        return y;
    }

    void Print()
    {
        cout << "X = " << x << "\tY = " << y << endl << endl;
    }

    bool operator == (const Point& other)             // opersator ==
    {
        return this->x == other.x && this->y == other.y;
    }

    bool operator != (const Point& other)            // opersator !=
    {
        return !(this->x == other.x && this->y == other.y);
        // return this->x != other.x || this->y != other.y;
    }

    Point operator + (const Point& other)
    {
        return Point(this->x + other.x, this->y + other.y);
    }

    void operator += (const Point& other)
    {
        this->x += other.x;
        this->y += other.y;
        
    }

    Point& operator ++()       // ПРЕФИКСНЫЙ инкремент ++X
    {
        this->x++;
        this->y++;
        return *this;     // this - это указатель, надо его разименовать
    }

    Point& operator ++(int value)       // ПОСТФИКСНЫЙ инкремент X++. int value - для компиллятора
    {
        Point temp(*this);              // ЗАПОМИНАЕМ состояние thjs с помощью конструктора копирования в переменную temp
        this->x++;                      // делаем инкремент самого объекта this
        this->y++;
        return temp;                    // возвращаем ПЕРВОНАЧАЛЬНОЕ состояние объекта this в виде копии - temp
    }

    Point& operator --()       // ПРЕФИКСНЫЙ декремент --X
    {
        this->x--;
        this->y--;
        return *this;     // this - это указатель, надо его разименовать
    }

    Point& operator --(int value)       // ПОСТФИКСНЫЙ декремент X--. int value - для компиллятора
    {
        Point temp(*this);              // ЗАПОМИНАЕМ состояние thjs с помощью конструктора копирования в переменную temp
        this->x--;                      // делаем инкремент самого объекта this
        this->y--;
        return temp;                    // возвращаем ПЕРВОНАЧАЛЬНОЕ состояние объекта this в виде копии - temp
    }
};

int main()
{
    setlocale(LC_ALL, "ru");
    /*
    Point a(15, 11);
    Point b(15, 11);
    Point c;
    c = a + b;
    c.Print();
    a += b;
    a.Print();
    ++a;
    a.Print();
    */

    Point a(1, 1);

    Point b = a++;
    a.Print();
    b.Print();

    Point c(2, 2);
    c.Print();
    --c;
    c.Print();
    Point d = c--;
    d.Print();
    c.Print();

    return 0;
}


###### Урок #87 - Перегрузка оператора индексирования . Перегрузка операторов пример. C++ Для начинающих
#include <iostream>
using namespace std;

class TestClass
{
public:
    int& operator [](int index)        // ВОЗВРАЩАЕМ ПО ССЫЛКЕ. Прегрузка оператора [i]
    {
        return arr[index];
    }
private:
    int arr[5]{ 5,44,4,987,69 };
};



int main()
{
    setlocale(LC_ALL, "ru");

    TestClass a;
    cout << a[2] << endl;
    a[2] = 777;
    cout << a[2] << endl;

    return 0;
}


###### Урок #88 - Дружественные функции и классы пример. Для чего используются. Как определяются. Для двух классов
#include <iostream>
using namespace std;

class Test;        // типа прототипа класса

class Point
{
private:
    int x;
    int y;

public:
    Point()
    {
        x = 0;
        y = 0;
        cout << this << " - constructor" << endl;
    }

    Point(int valueX, int valueY)
    {
        x = valueX;
        y = valueY;
        cout << this << " - constructor" << endl;
    }

    /*
    void SetX(int valueX)
    {
        x = valueX;
    }

    void SetY(int y)
    {
        this->y = y;                         // this->
    }
    */

    int GetX()
    {
        return x;
    }

    int GetY()
    {
        return y;
    }

    void Print()
    {
        cout << "X = " << x << "\tY = " << y << endl << endl;
    }

    bool operator == (const Point& other)             // opersator ==
    {
        return this->x == other.x && this->y == other.y;
    }

    bool operator != (const Point& other)            // opersator !=
    {
        return !(this->x == other.x && this->y == other.y);
        // return this->x != other.x || this->y != other.y;
    }

    Point operator + (const Point& other)
    {
        return Point(this->x + other.x, this->y + other.y);
    }

    void operator += (const Point& other)
    {
        this->x += other.x;
        this->y += other.y;
        
    }

    Point& operator ++()       // ПРЕФИКСНЫЙ инкремент ++X
    {
        this->x++;
        this->y++;
        return *this;     // this - это указатель, надо его разименовать
    }

    Point& operator ++(int value)       // ПОСТФИКСНЫЙ инкремент X++. int value - для компиллятора
    {
        Point temp(*this);              // ЗАПОМИНАЕМ состояние thjs с помощью конструктора копирования в переменную temp
        this->x++;                      // делаем инкремент самого объекта this
        this->y++;
        return temp;                    // возвращаем ПЕРВОНАЧАЛЬНОЕ состояние объекта this в виде копии - temp
    }

    Point& operator --()       // ПРЕФИКСНЫЙ декремент --X
    {
        this->x--;
        this->y--;
        return *this;     // this - это указатель, надо его разименовать
    }

    Point& operator --(int value)       // ПОСТФИКСНЫЙ декремент X--. int value - для компиллятора
    {
        Point temp(*this);              // ЗАПОМИНАЕМ состояние thjs с помощью конструктора копирования в переменную temp
        this->x--;                      // делаем инкремент самого объекта this
        this->y--;
        return temp;                    // возвращаем ПЕРВОНАЧАЛЬНОЕ состояние объекта this в виде копии - temp
    }

    friend void ChangeX(Point& value, Test& testValue);    // ключевое слово friend. НЕ ЗАВИСИТ ОТ МОДИФИКАТОРОВ ДОСТУПА!!!
};


class Test
{
private:
    int Data = 0;

    friend void ChangeX(Point& value, Test& testValue);
};


void ChangeX(Point& value, Test &testValue)
{
    value.x = -1;
    testValue.Data = -1;
}


int main()
{
    setlocale(LC_ALL, "ru");

    Test test;
    Point a(5, 12);
    a.Print();
    ChangeX(a, test);
    a.Print();
    return 0;
}


###### Урок #89 - Определение методов вне класса. Вынести функцию в из класса. Вынести описание метода вне класса.
#include <iostream>
#include <string>
using namespace std;

class MyClass
{
public:
    MyClass();
    ~MyClass();
    void PrintMesage();

private:

};

MyClass::MyClass()
{
}

MyClass::~MyClass()
{
}

void MyClass::PrintMesage()
{
    cout << "HELLO!" << endl;
}


int main()
{
    setlocale(LC_ALL, "ru");
    MyClass a;
    a.PrintMesage();
    
    return 0;
}


###### Урок #90 - Дружественный метод класса. ООП. friend c++ что это. Функции друзья. C++ Для начинающих.
#include <iostream>
#include <string>
using namespace std;

class Apple;
class Human;

class Human
{
public:
    void TakeApple(Apple& apple);
};

class Apple
{
public:
    Apple(int weight, string color)
    {
        this->weight = weight;
        this->color = color;
    }

private:
    int weight;
    string color;

    friend void Human::TakeApple(Apple& apple);
};

void Human::TakeApple(Apple& apple)                           // метод вынести пришлось отдельно, чтобы он стал дружественным
{
    cout << "I took a " << apple.color << " apple with weght " << apple.weight << "g" << endl;
}


int main()
{
    setlocale(LC_ALL, "ru");

    Apple a(150, "red");
    Human man1;
    man1.TakeApple(a);
    return 0;
}


###### Урок #91 - Дружественные классы. ООП. friend class. friend c++ что это. C++ Для начинающих.
#include <iostream>
#include <string>
using namespace std;

class Apple;
class Human;

class Human
{
public:
    void TakeApple(Apple& apple);

    void EatApple(Apple& apple)
    {
        
    }
};

class Apple
{
public:
    Apple(int weight, string color)
    {
        this->weight = weight;
        this->color = color;
    }

private:
    int weight;
    string color;

    friend Human;
};


void Human::TakeApple(Apple &apple)              // дружественностью лучше не увлекаться (доступ к private - нарушение инкапсуляции)
{
    apple.color = "";
    cout << "I took a " << apple.color << " apple with weght " << apple.weight << "g" << endl;
}


int main()
{
    setlocale(LC_ALL, "ru");

    Apple a(150, "red");
    Human man1;
    man1.TakeApple(a);
    
    return 0;
}


###### Урок #92 - static что это. Статические поля класса. Инициализация. Ключевое слово static.
#include <iostream>
#include <string>
using namespace std;

class Apple;
class Human;

class Human
{
public:
    void TakeApple(Apple& apple);

    void EatApple(Apple& apple)
    {
        
    }
};

class Apple
{
public:
    static int Count;

    Apple(int weight, string color)
    {
        Count++;                 // при создании объекта увеличиваем переменную Count на 1
        this->weight = weight;
        this->color = color;
    }

private:
    int weight;
    string color;

    friend Human;
};

int Apple::Count = 0;           // инициализация статической переменной - ВНЕ КЛАССА


void Human::TakeApple(Apple &apple)
{
    cout << "I took a " << apple.color << " apple with weght " << apple.weight << "g" << endl;
}


int main()
{
    setlocale(LC_ALL, "ru");

    cout << Apple::Count << endl;

    Apple a1(150, "red");
    Apple a2(250, "blue");
    Apple a3(170, "yellow");
    Apple a4(160, "green");

    cout << a1.Count << endl;
    cout << a2.Count << endl;
    cout << a3.Count << endl;
    cout << a4.Count << endl;
    cout << Apple::Count << endl;
    
    return 0;
}


###### Домашнее задание - Написать генератор идентификаторов для объектов класса используя статическую переменную.
#include <iostream>
#include <string>
using namespace std;

class Human
{
public:
    static int Count;

    Human(string name)
    {
        this->name = name;
        Count++;
        id = Count;
    }

    int GetId()
    {
        return id;
    }

    void Print()
    {
        cout << "Name: " << name << "\tID: " << id << endl;
    }

private:
    int id;
    string name;
};

int Human::Count = 0;

int main()
{
    setlocale(LC_ALL, "ru");
    Human usr1("Roman");
    Human usr2("Ivan");
    Human usr3("Roman");
    Human usr4("Shamil");

    usr1.Print();
    cout << usr2.GetId() << endl;
    usr3.Print();
    usr4.Print();

    return 0;
}


###### Урок #93 - id generator. Генератор уникальных идентификаторов с использованием static переменной Начинающим


###### Урок #94 - Статические методы класса зачем нужны. Модификатор static. Как влияет. ООП. Для начинающих.
#include <iostream>
#include <string>
using namespace std;

class Human
{
public:
    static int Count;

    Human(string name)
    {
        this->name = name;
        Count++;
        id = Count;
    }

    int GetId()
    {
        return id;
    }

    void Print()
    {
        cout << "Name: " << name << "\tID: " << id << endl;
    }

private:
    int id;
    string name;
};

int Human::Count = 0;

class Apple
{

public:
    

    Apple(int weight, string color)
    {
        this->weight = weight;
        this->color = color;
        Count++;
        id = Count;
    }

    int GetId()
    {
        return id;
    }

    static int GetCount()      // чтобы можно было получать из самого класса - Apple::GetCount()
    {                          // статическая функция НЕ ОТНОСИТСЯ К ОБЪЕКТАМ КЛАССА - но оносится К КЛАССУ
        return Count;          // а стат. методе можно раб. ТОЛЬКО СО СТАТИЧЕСКИМИ ПЕРЕМЕННЫМИ !!!
    }

    static void ChangeColor(Apple & apple, string color)
    {
        apple.color = color;
    }

private:
    static int Count;
    int weight;
    string color;
    int id;

};

int Apple::Count = 0;

int main()
{
    setlocale(LC_ALL, "ru");

    Apple apple(150, "Red");

    apple.ChangeColor(apple, "Green");
    Apple::ChangeColor(apple, "BLUE");

    /*
    Apple apple2(250, "Green");
    Apple apple3(100, "Yellow");

    cout << apple.GetId() << endl;
    cout << apple2.GetId() << endl;
    cout << apple3.GetId() << endl;
    cout << endl << Apple::GetCount() << endl;
    cout << apple3.GetCount() << endl;
    */

    return 0;
}


###### Урок #95 - Вложенные классы с++ пример. Внутренние классы. Зачем нужны. inner class. ООП.
#include <iostream>
#include <string>
using namespace std;

class Image
{

public:
    int a = 0;
    

    void GetImageInfo()
    {
        for (int i = 0; i < 5; i++)
        {
            cout << "#" << i << pixels[i].GetInfo() << endl;
        }
    }

    class Pixel                     // ведут себя как разные классы, просто один находится внутри другого
    {                              // а видимость класса Pixel зависит от того, в какой области класса Image он находится
    public:
        Pixel(int r, int g, int b)
        {
            this->r = r;
            this->g = g;
            this->b = b;
        }

        string GetInfo()
        {
            return " Pixel: r = " + to_string(r) + " g = " + to_string(g) + " b = " + to_string(b);
        }

    private:
        int r;
        int g;
        int b;

    };

private:
    static const int LENGTH = 5;

    Pixel pixels[LENGTH]
    {
        Pixel(0,4,64),
        Pixel(4,14,10),
        Pixel(111,4,24),
        Pixel(244,244,14),
        Pixel(111,179,64)
    };

};


int main()
{
    setlocale(LC_ALL, "ru");
    //Image a;
   // a.GetImageInfo();

    Image::Pixel pixel(100, 200, 100);
    cout << pixel.GetInfo();

    return 0;
}


###### Урок #96 - Массив объектов класса. Динамический. Статический. Создание Особенности. ООП C++ Для начинающих
#include <iostream>
#include <string>
using namespace std;

class Pixel                     
{                              
public:
    Pixel()
    {
        r = g = b = 0;
    }
    
    Pixel(int r, int g, int b)
    {
        this->r = r;
        this->g = g;
        this->b = b;
    }

    string GetInfo()
    {
        return " Pixel: r = " + to_string(r) + " g = " + to_string(g) + " b = " + to_string(b);
    }

    int test = 1000;
private:
    int r;
    int g;
    int b;
};


int main()
{
    setlocale(LC_ALL, "ru");
    
    /*
    const int LENGTH = 5;
    
    Pixel p(1, 2, 33);
    Pixel arr[LENGTH]
    {
        Pixel(12,3,14),
        Pixel(10,11,25),
        Pixel(143,23,90),
        Pixel(121,89,76),
        Pixel(4,15,28)
    };

    arr[0] = Pixel(111,111,111);
    cout << arr[0].GetInfo() << endl;     // можем обращаться к полям и методам объекта
    */
    int LENGTH = 5;
    Pixel* arr = new Pixel[LENGTH];
    arr[0] = Pixel(10, 11, 12);  
    cout << arr[0].GetInfo() << endl;

    delete[] arr;

    return 0;
}


###### Урок #97 - Что такое агрегация и композиция. Отношения между классами и объектами. ООП. C++ Для начинающих
#include <iostream>
#include <string>
using namespace std;

class Cap    // агрегация - жестко НЕ привязан к конкретному классу
{
public:
    string GetColor()
    {
        return color;
    }
private:
    string color = "red";
};

class Mannequin
{
public:
    void InspectMannequin()
    {
        cout << "The cap is " << cap.GetColor() << " color." << endl;
    }
private:
    Cap cap;
};

class Human
{
public:
    void Think()
    {
        brain.Think();    // Делегирование - один шаблонов ООП - когда метод класса вызывает метод другого класса
    }

    void InspectTheCap()
    {
        cout << "My cap is " << cap.GetColor() << " color." << endl;
    }

private:

    class Brain     // Композиция - класс мозг зависит от класса Humans
    {
    public:
        void Think()
        {
            cout << "I think!" << endl;
        }
    };

    Brain brain;
    Cap cap;
};

int main()
{
    setlocale(LC_ALL, "ru");

    Human human;
    human.Think();
    human.InspectTheCap();

    Mannequin m;
    m.InspectMannequin();

    return 0;
}


###### Урок #98 - Наследование в ООП пример. Что такое наследование. Для чего нужно наследование классов. ООП. C++
#include <iostream>
#include <string>
using namespace std;

class Human
{
private:
    string name;
public:
    string Getname()
    {
        return name;
    }

    void SetName(string name)
    {
        this->name = name;
    }
};

class Student : public Human
{
public:
    string group;

    void Learn()
    {
        cout << "I learn!" << endl;
    }
};

class ExtramuralStudent : public Student
{
public:
    void Learn()
    {
        cout << "I visit the Institute less often than an ordinary student!" << endl;
    }
};

class Professor : public Human
{
public:
    string subject;
};

int main()
{
    setlocale(LC_ALL, "ru");
    
    Student st;
    st.Learn();
    st.SetName("Robin Goood");
    cout << st.Getname() << endl;

    ExtramuralStudent extraSt;
    extraSt.SetName("Evoly");
    extraSt.Learn();
    cout << extraSt.Getname() << endl;

    return 0;
}


###### Урок #99 - Модификаторы доступа при наследовании. private public protected Спецификаторы доступа. ООП. C++
#include <iostream>
#include <string>
using namespace std;

class A
{
public:                                   // доступно всем и везде 
    string msgOne = "Message #1";

private:                                  // доступно только внутри класса, в котором создано
    string msgTwo = "Message #2";

protected:                               // доступно на уровне класса-наследника, но НЕДОСТУПНО на уровне объектов класса
    string msgThree = "Message #3";
};

class B : public A    // класс B имеет все поля класса A, но доступ имеет не ко всем
{
public:    
    void PrintMsg()
    {
        cout << msgOne << endl;
        cout << msgThree << endl;
    }
};

class C : private A
{
public:
    void COUT()
    {
        cout << PRINT.msgOne << endl;
    }
private:
    A PRINT;
};

class D : protected A
{
public:
    void COUT()
    {
        cout << PR.msgOne << endl;
    }
private:
    A PR;
};

int main()
{
    setlocale(LC_ALL, "ru");
    B b;
    //b.PrintMsg();
    C c;
    c.COUT();
    D d;
    d.COUT();

    return 0;
}


###### Урок #100 - Порядок вызова конструкторов при наследовании. Как вызываются конструкторы. ООП C++ Начинающим
#include <iostream>
#include <string>
using namespace std;

class A
{
public:                                   
    A()
    {
        cout << "Called a constructor of class A." << endl;
    }

};

class B : public A
{
public:    
    B()
    {
        cout << "Called a constructor of class B." << endl;
    }
};

class C : public B
{
public:
    C()
    {
        cout << "Called a constructor of class C." << endl;
    }
};

int main()
{
    setlocale(LC_ALL, "ru");

    C c;   // для создания объекта класса С создаются объекты классво В и С (через конструктор классов)

    return 0;
}


###### Урок #101 - Порядок вызова деструкторов при наследовании. Деструкторы. ООП C++ Для начинающих.
#include <iostream>
#include <string>
using namespace std;

class A
{
public:                                   
    A()
    {
        cout << "Called a constructor of class A." << endl;
    }

    ~A()
    {
        cout << "Called a destructor of class A." << endl;
    }
};

class B : public A
{
public:    
    B()
    {
        cout << "Called a constructor of class B." << endl;
    }

    ~B()
    {
        cout << "Called a destructor of class B." << endl;
    }
};

class C : public B
{
public:
    C()
    {
        cout << "Called a constructor of class C." << endl;
    }

    ~C()
    {
        cout << "Called a destructor of class C." << endl;
    }
};

int main()
{
    setlocale(LC_ALL, "ru");

    C c;   

    return 0;
}        // деструкторы вызываются в обратном порядке, аналогично матрёшке или пирамидке


###### Урок #102 - Вызов конструктора базового класса из конструктора класса-наследника. Наследование. ООП C++
#include <iostream>
#include <string>
using namespace std;

class A
{
public:
    A()
    {
        msg = "Empty message";
    }

    A(string msg)
    {
        this->msg = msg;
    }

    A(string msg, int value)
    {
        this->msg = msg;
    }

    void PrintMsg()
    {
        cout << msg << endl;
    }
private:
    string msg;
};

class B : public A
{
public:
    B():A("Our new message.", 10)    // указываем конкретный контсруктор ( по умолчанию - A() )
    {

    }

};


int main()
{
    setlocale(LC_ALL, "ru");
    //A a("OUR STRING");
    //a.PrintMsg();

    B value;
    value.PrintMsg();

    return 0;
}


###### Урок #103 - Виртуальные методы класса c++. Ключевое слово virtual. Ключевое слово override. ООП. C++
#include <iostream>
#include <string>
using namespace std;

class Gun
{
public:
    virtual void Shoot()    // virtual - позволяет ПЕРЕОПРЕДЕЛЯТЬ данный метод, чтобы, спользуя лишь УКАЗАТЕЛЬ на БАЗОВЫЙ
    {                       // класс менять поведение классов-наследников
        cout << "BANG!" << endl;
    }
};

class Bazooka : public Gun
{
public:
    void Shoot() override   // слово override нужно для того, чтобы КОМПИЛЛЯТОР контроллирвоал правильность переопределения         
    {
        cout << "BADABOOM!" << endl;
    }
};

class SubmachineGun : public Gun
{
public:
    void Shoot() override   // слово override нужно для того, чтобы КОМПИЛЛЯТОР контроллирвоал правильность переопределения         
    {
        cout << "BANG! BANG! BANG!" << endl;
    }
};

class Player
{
public:
    void Shoot(Gun *gun)
    {
        gun->Shoot();
    }
};

int main()
{
    setlocale(LC_ALL, "ru");
    Gun gun;
    SubmachineGun machinegun;
    Bazooka bazooka;
    Gun *weapon = &gun;
    Gun *weapon = &machinegun;  // указатель может указ. на объект класса Gun и на любой объект дочерних классов
    weapon->Shoot();

    Player player;
    player.Shoot(&bazooka);

    return 0;
}


###### Урок #104 - Абстрактный класс с++ пример. Чисто виртуальная функция. virtual. override. Полиморфизм ООП C++
#include <iostream>
#include <string>
using namespace std;

class Weapon         // абстрактный класс - хоть 1 методя явл. чистой виртуальной ф-ей.
{                    // НЕЛЬЗЯ создавать объекты (экземпляры) чисто виртуального класса
public:    
    virtual void Shoot() = 0;       // указание чсито вирутальной функции
    
    void Foo()                  // обычный метод у абстрактного класса
    {
        cout << "Foo()" << endl;
    }

};


class Gun : public Weapon
{
public:
    virtual void Shoot()    
    { 
        cout << "BANG!" << endl;
    }
};

class Bazooka : public Weapon
{
public:
    void Shoot() override         
    {
        cout << "BADABOOM!" << endl;
    }
};

class SubmachineGun : public Gun
{
public:
    void Shoot() override        
    {
        cout << "BANG! BANG! BANG!" << endl;
    }
};

class Knife : public Weapon
{
public:
    void Shoot() override       // необходимо РЕАЛИЗОВАТЬ чисто виртуальный метод абстрактного класса, 
    {                           // иначе не поулчится созд. объекты данного класса 
        cout << "VJUH!!!" << endl;
    }
};

class Player
{
public:
    void Shoot(Weapon *weapon)
    {
        weapon->Shoot();
    }
};

int main()
{
    setlocale(LC_ALL, "ru");
    //Bazooka bazooka;
    Knife knife;

    Player player;
    player.Shoot(&knife);
    
    knife.Foo();

    return 0;
}


###### Урок #105 - Виртуальный деструктор класса C++. Что это такое. Наследование. Полиморфизм. Для начинающих
#include <iostream>
#include <string>
using namespace std;

class A
{
public:
    A()
    {
        cout << "Выделена динамическая память, объект класса А" << endl;
    }

    virtual ~A()
    {
        cout << "Освобождена динамическая память, объект класса А" << endl;
    }
};

class B : public A   // объект класса В фактически содержит объект класса А, чтобы можно было пользоваться его методами и полями 
{
public:
    B()
    {
        cout << "Выделена динамическая память, объект класса B" << endl;
    }

    ~B() override
    {
        cout << "Освобождена динамическая память, объект класса B" << endl;
    }
};


int main()
{
    setlocale(LC_ALL, "ru");

    //B* bptr = new B;
    A* bptr = new B;     // указатель на базовый класс (А) может хранить ссылки на любых своих потомков
    delete bptr;     

    return 0;
}


###### Урок #106 - Чисто виртуальный деструктор c++. Наследование. Полиморфизм. virtual. override. Для начинающих
#include <iostream>
#include <string>
using namespace std;



class A
{
public:
    A()
    {
        
    }
    virtual ~A() = 0;
};

A::~A(){};

class B : public A   
{
public:
    B()
    {
        cout << "Выделена динамическая память, объект класса B" << endl;
    }
    ~B() override
    {
        cout << "Освобождена динамическая память, объект класса B" << endl;
    }
};


int main()
{
    setlocale(LC_ALL, "ru");

    A* bptr = new B;     
    delete bptr;     

    return 0;
}


###### Урок #107 - Делегирующие конструкторы c++. Вызов конструктора из конструктора. ООП. С++ Для начинающих.
#include <iostream>
#include <string>
using namespace std;

class Human
{
public:
    Human(string Name)
    {
        this->Name = Name;
        this->Age = 0;
        this->Weight = 0;
    }

    Human(string Name, int Age) : Human(Name)
    {
        this->Age = Age;
    }

    Human(string Name, int Age, int Weight) : Human(Name, Age)
    {
        this->Weight = Weight;
    }

private:
    string Name;
    int Age;
    int Weight;
};

int main()
{
    setlocale(LC_ALL, "ru");

    Human h("Аристарх", 30, 70);

    return 0;
}


###### Урок #108 - c++ вызов виртуального метода базового класса. ООП. Изучение с++ с нуля. Для начинающих.
#include <iostream>
#include <string>
using namespace std;

class Msg
{
public:
    Msg(string msg)
    {
        this->msg = msg;
    }

    virtual string GetMsg()
    {
        return msg;
    }
private:
    string msg;
};

class BraketsMsg : public Msg
{
public:
    BraketsMsg(string msg) : Msg(msg)
    {

    }

    string GetMsg() override
    {
        return "[" + ::Msg::GetMsg() + "]";   // Указываем явно - вызываем метод БАЗОВОГО класса!!! 
    }
};

class Printer
{
public:
    void Print(Msg* msg)
    {
        cout << msg->GetMsg() << endl;
    }
};

int main()
{
    setlocale(LC_ALL, "ru");
    BraketsMsg m("Hello!");
    Printer p;
    p.Print(&m);

    return 0;
}


###### Урок #109 - Множественное наследование c++ пример. ООП. Изучение С++ с нуля для начинающих.
#include <iostream>
#include <string>
using namespace std;

class Car
{
public:
    string str = "Поле класса машина";

    void Drive()
    {
        cout << "Я еду!" << endl;
    }
};

class Airplain
{
public:
    string str2 = "Поле класса самолёт";

    void Fly()
    {
        cout << "Я лечу!" << endl;
    }
};

class FlyingCar : public Car, public Airplain
{

};

int main()
{
    setlocale(LC_ALL, "ru");

    FlyingCar fc;
    //fc.Drive();
    //fc.Fly();
    Car* ptrC = &fc;           // указатель типа БАЗОВОГО класса на КЛАСС-НАСЛЕДНИК
    Airplain* ptrA = &fc;

    return 0;
}


###### Урок #110 - Порядок вызова конструкторов при множественном наследовании. ООП. С++ начинающих.
#include <iostream>
#include <string>
using namespace std;

class Car
{
public:
    Car()
    {
        cout << "Вызов контсруктора класса Car" << endl;
    }

    void Drive()
    {
        cout << "Я еду!" << endl;
    }
};

class Airplain
{
public:
    Airplain()
    {
        cout << "Вызов контсруктора класса Airplain" << endl;
    }

    void Fly()
    {
        cout << "Я лечу!" << endl;
    }
};

class FlyingCar : public Airplain, public Car
{
public:
    FlyingCar()
    {
        cout << "Вызов конструктора класса FlyingCar" << endl;
    }
    
};

int main()
{
    setlocale(LC_ALL, "ru");

    FlyingCar fc;

    return 0;
}


###### Урок #111 - Порядок вызова деструкторов при множественном наследовании. ООП. С++ начинающих.
#include <iostream>
#include <string>
using namespace std;

class Car
{
public:
    Car()
    {
        cout << "Вызов конструктора класса Car" << endl;
    }

    void Drive()
    {
        cout << "Я еду!" << endl;
    }

    ~Car()
    {
        cout << "Вызов деструктора класса Car" << endl;
    }
};

class Airplain
{
public:
    Airplain()
    {
        cout << "Вызов конструктора класса Airplain" << endl;
    }

    void Fly()
    {
        cout << "Я лечу!" << endl;
    }

    ~Airplain()
    {
        cout << "Вызов деструктора класса Airplain" << endl;
    }
};

class FlyingCar : public Car, public Airplain
{
public:
    FlyingCar()
    {
        cout << "Вызов конструктора класса FlyingCar" << endl;
    }
    
    ~FlyingCar()
    {
        cout << "Вызов деструктора класса FlyingCar" << endl;
    }
};

int main()
{
    setlocale(LC_ALL, "ru");

    FlyingCar fc;

    return 0;
}


###### Урок #112 - С++ множественное наследование одинаковые методы. ООП. Изучение С++ для начинающих.
#include <iostream>
#include <string>
using namespace std;

class Car
{
public:
    void Use()
    {
        cout << "Я еду!" << endl;
    }

};

class Airplain
{
public:
    void Use()
    {
        cout << "Я лечу!" << endl;
    }

};

class FlyingCar : public Car, public Airplain
{
public:

   
};

int main()
{
    setlocale(LC_ALL, "ru");

    FlyingCar fc;
    ((Car)fc).Use();    // приведение типов в стиле Си
    
    cout << endl << endl;
    
    ((Airplain)fc).Use();

    return 0;
}


###### Урок #113 - Что такое интерфейс в ООП. Интерфейс c++ пример. Изучение С++ для начинающих.