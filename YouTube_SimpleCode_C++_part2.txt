###### ПРЕДЫДУЩИЕ УРОКИ - в файле YouTube_SimpleCode_C++_part1.txt

###### Урок #129 - Структуры в C++ | struct C++. Разница между структурой и классом. Изучение С++ для начинающих.
#include <iostream>
#include <string>
using namespace std;

/*
class MyClass
{
public:                     
    int a = 10;

    void Print() { cout << a << endl; }
};


struct MyStruct     // по умолчанию все поля и методы - public. При наследовании наследуются они как public
{
    MyStruct()
    {
        a = 0;
    }
    MyStruct(int a)
    {
        this->a = a;
    }
    ~MyStruct()
    {
    }

private:
    int a;
    void Print() { cout << a << endl; }
};
*/

class MyClass1
{
public:
    int a = 10;
};

class MyClass2 : public MyClass1      // по умолчанию - private
{
};

struct MyStruct1
{
    int a = 22;
};

struct MyStruct2 : MyStruct1
{
};

int main()
{
    setlocale(LC_ALL, "ru");
    MyClass1 m;
    MyStruct1 ms;
    MyClass2 m2;
    MyStruct2 ms2;
    
    cout << m2.a << endl;
    cout << ms2.a << endl;
    //ms.Print();
    
    return 0;
}


###### Урок #130 - Умные указатели. Smart pointers. Изучение С++ для начинающих.
#include <iostream>
#include <string>
using namespace std;

template<typename T>
class SmartPointer
{
public:

    SmartPointer(T *ptr)
    {
        this->ptr = ptr;
        cout << "Constructor" << endl;
    }
    
    ~SmartPointer()
    {
        delete ptr;
        cout << "Destructor" << endl;
    }

    T& operator * ()    // T& - сслыка на те данные, которые хотим передавать
    {
        return *ptr;
    }

private:
    T *ptr;      // тут в объекте класса будет храниться указатель
};


int main()
{
    setlocale(LC_ALL, "ru");
    /*
    int* ptr = new int(5);     // выделяем место в динамической памяти
    delete ptr;
    */
    SmartPointer<int> pointer = new int(5);   // new - возвращает указатель
    *pointer = 1638276;

    cout << *pointer << endl;

    return 0;
}


###### Урок #131 - auto_ptr | unique_ptr | shared_ptr | Умные указатели. Изучение С++ для начинающих.
#include <iostream>
#include <string>
#include <memory>             // !!!
using namespace std;



template<typename T>
class SmartPointer
{
public:

    SmartPointer(T *ptr)
    {
        this->ptr = ptr;
        cout << "Constructor" << endl;
    }
    
    ~SmartPointer()
    {
        delete ptr;
        cout << "Destructor" << endl;
    }

    T& operator * ()  
    {
        return *ptr;
    }

private:
    T *ptr;    
};


int main()
{
    setlocale(LC_ALL, "ru");
    
    shared_ptr<int> p1(new int(5));        // BEST PRACTICE
    shared_ptr<int> p2(p1);
    
    
    /*
    int* p = new int(5);
    unique_ptr<int> p1(p);
    p1.reset();
    p1.release();

    unique_ptr<int> p1(new int(5));
    int* p = p1.get();            // выдаёт УКАЗАТЕЛЬ в его сыром чистом виде
    //unique_ptr<int> p2(p1);     // ERROR!!! не даст сосслаться на другой unique_ptr
    unique_ptr<int> p2;
    p2.swap(p1);                // АНАЛОГ: p2 = move(p1);
    */
    
    //auto_ptr<int> ap1(new int(5));
    //auto_ptr<int> ap2(ap1);

    //SmartPointer<int> sp1 = new int(5); 
    //SmartPointer<int> sp2 = sp1;      // повторный вызов деструктора вызывает ошибку!
    
    return 0;
}


###### Урок #132 - Динамический массив и умные указатели. Изучение С++ для начинающих.
#include <iostream>
#include <string>
#include <memory>             
using namespace std;


int main()
{
    setlocale(LC_ALL, "ru");
    
    int size;
    cout << "Введите размер массива: ";
    cin >> size;
    cout << endl;

    //int* arr = new int[size] { 1, 6, 44, 9, 8 };
    //shared_ptr<int[]> ptr(arr);
    shared_ptr<int[]> ptr(new int[size]);
    
    cout << "Массив заполен псевдослучайными числами:" << endl;
    for (int i = 0; i < size; i++)
    {
        ptr[i] = rand() % 10;
        cout << ptr[i] << endl;
    }

    return 0;
}


###### Односвязный список | Динамические структуры данных #1
#https://youtu.be/C9FK1pHLnhI


###### Двусвязный список | Динамические структуры данных #2
#https://youtu.be/lQ-lPjbb9Ew


###### Бинарное дерево. Полное понимание! Динамические структуры данных #3
#https://youtu.be/9o_i0zzxk1s


###### Стек как структура данных. Полное понимание! Динамические структуры данных #4


###### Очередь как структура данных. Динамические структуры данных #5


###### Очередь с приоритетом | Кольцевая очередь | Динамические структуры данных #6


###### Дек | Deque | Динамические структуры данных #7


###### Урок #133 - Реализация односвязного списка c++ Часть 1 | Урок #133
#include <iostream>
#include <string>
using namespace std;

template<typename T>
class List
{
public:
    List();
    ~List();

    void push_back(T data);
    int GetSize(){ return Size; }

    T& operator[](const int index);


private:
    template<typename T>
    class Node
    {
    public:
        Node* pNext;      // указатель на следующий элемент типа Node
        T data;

        Node(T data=T(), Node *pNext=nullptr)     // T() - констурктор по умолчанию (лишь бы не мусор). Последн. Node указ-ет на nullptr
        {
            this->data = data;
            this->pNext = pNext;
        }
    };

    int Size;         // кол-во элементов с списке      
    Node<T> *head;    // указатель на первый элемент. Все элементы односвязного списка хранятся в динамической памяти
};

template<typename T>
List<T>::List()
{
    Size = 0;           // список при создании пуст
    head = nullptr;     // первого элемента ещё нет
}

template<typename T>
List<T>::~List()
{
}

template<typename T>
void List<T>::push_back(T data)      // добавить данный в конец списка = добавление элемента в конец списка
{
    if (head == nullptr)
    {
        head = new Node<T>(data);
    }
    else
    {
        Node<T>* current = this->head;     // временная переменная - для поиска последнего элемента одн. списка

        while (current->pNext != nullptr)    
        {
            current = current->pNext;
        }
        current->pNext = new Node<T>(data);

    }

    Size++;
}

template<typename T>
T& List<T>::operator[](const int index)
{
    int counter = 0;
    Node<T>*current = this->head;

    while (current != nullptr)
    {
        if (counter == index)
        {
            return current->data;
        }
        current = current->pNext;
        counter++;
    }
}



int main()
{
    setlocale(LC_ALL, "ru");

    List<int> lst;
    /*
    lst.push_back(5);
    lst.push_back(10);
    lst.push_back(22);
    */
    int numbersCount;
    cout << "Введите размер односвязного списка: " << endl;
    cin >> numbersCount;

    for (int i = 0; i < numbersCount; i++)
    {
        lst.push_back(rand() % 10);
    }
    
    for (int i = 0; i < numbersCount; i++)
    {
        cout << lst[i] << " ";
    }
    cout << endl;

    return 0;
}


###### Урок #134 - Реализация односвязного списка c++ Часть 2 | Урок #134
#include <iostream>
#include <string>
using namespace std;

template<typename T>
class List
{
public:
    List();
    ~List();

    void pop_front();
    void push_back(T data);
    void clear();
    int GetSize(){ return Size; }
    T& operator[](const int index);

private:
    template<typename T>
    class Node
    {
    public:
        Node* pNext;      // указатель на следующий элемент типа Node
        T data;

        Node(T data=T(), Node *pNext=nullptr)     // T() - констурктор по умолчанию (лишь бы не мусор). Последн. Node указ-ет на nullptr
        {
            this->data = data;
            this->pNext = pNext;
        }
    };

    int Size;         // кол-во элементов с списке      
    Node<T> *head;    // указатель на первый элемент. Все элементы односвязного списка хранятся в динамической памяти
};

template<typename T>
List<T>::List()
{
    Size = 0;           // список при создании пуст
    head = nullptr;     // первого элемента ещё нет
}

template<typename T>
List<T>::~List()
{
    clear();
}

template<typename T>
void List<T>::clear()
{
    while (Size)
    {
        cout << "Вызван метод clear() для данных: " << this->head->data << endl;
        pop_front();
    }
}

template<typename T>
void List<T>::pop_front()
{
    Node<T>* temp = head;
    head = head->pNext;
    delete temp;
    Size--;
}

template<typename T>
void List<T>::push_back(T data)      // добавить данный в конец списка = добавление элемента в конец списка
{
    if (head == nullptr)
    {
        head = new Node<T>(data);
    }
    else
    {
        Node<T>* current = this->head;     // временная переменная - для поиска последнего элемента одн. списка

        while (current->pNext != nullptr)    
        {
            current = current->pNext;
        }
        current->pNext = new Node<T>(data);

    }

    Size++;
}

template<typename T>
T& List<T>::operator[](const int index)
{
    int counter = 0;
    Node<T>*current = this->head;

    while (current != nullptr)
    {
        if (counter == index)
        {
            return current->data;
        }
        current = current->pNext;
        counter++;
    }
}



int main()
{
    setlocale(LC_ALL, "ru");

    List<int> lst;
    /*
    lst.push_back(5);
    lst.push_back(10);
    lst.push_back(22);
    */
    int numbersCount;
    cout << "Введите размер односвязного списка: " << endl;
    cin >> numbersCount;

    for (int i = 0; i < numbersCount; i++)
    {
        lst.push_back(rand() % 10);
    }
    
    for (int i = 0; i < numbersCount; i++)
    {
        cout << lst[i] << " ";
    }
    cout << endl;

    //cout << "Выполняю метод clear()" << endl;
    lst.pop_front();
    //lst.clear();

    for (int i = 0; i < lst.GetSize(); i++)
    {
        cout << lst[i] << " ";
    }
    cout << endl;

    return 0;
}


###### Урок #135 - Реализация односвязного списка c++ Часть 3 | Урок #135
/*
МОЙ ВАРИАНТ РЕЛИЗАЦИИ МЕТОДОВ:
    void push_front(T data);
    void pop_back();
    void insert(T value, const int index);
    void removeAt(const int index);
*/
#include <iostream>
#include <string>
using namespace std;

template<typename T>
class List
{
public:
    List();
    ~List();

    void pop_front();
    void push_back(T data);
    void clear();
    void push_front(T data);
    void pop_back();
    void insert(T value, const int index);
    void removeAt(const int index);
    int GetSize(){ return Size; }
    T& operator[](const int index);

private:
    template<typename T>
    class Node
    {
    public:
        Node* pNext;      // указатель на следующий элемент типа Node
        T data;

        Node(T data=T(), Node *pNext=nullptr)     // T() - констурктор по умолчанию (лишь бы не мусор). Последн. Node указ-ет на nullptr
        {
            this->data = data;
            this->pNext = pNext;
        }
    };

    int Size;         // кол-во элементов с списке      
    Node<T> *head;    // указатель на первый элемент. Все элементы односвязного списка хранятся в динамической памяти
};

template<typename T>
List<T>::List()
{
    Size = 0;           // список при создании пуст
    head = nullptr;     // первого элемента ещё нет
}

template<typename T>
List<T>::~List()
{
    clear();
}

template<typename T>
void List<T>::clear()
{
    while (Size)
    {
        cout << "Вызван метод clear() для данных: " << this->head->data << endl;
        pop_front();
    }
}

template<typename T>
void List<T>::insert(T value, const int index)
{
    if (index == 0)    // если индекс = 0, то вставляем в начало - метод push_front()
    {
        push_front(value);
        return;
    }
    if (index == Size)    // если индекс = Size, то вставляем в конец - метод push_back()
    {
        push_back(value);    
        return;
    }
    // при вставке в середину делаем следующее:
    int counter = 0;
    Node<T>* current = head;
    Node<T>* previous = new Node<T>();
    while (current->pNext != nullptr)
    {
        previous = current;
        current = current->pNext;
        counter++;
        if (counter == index)
        {
            previous->pNext = new Node<T>(value, current);
        }
    }
    Size++;
}

template<typename T>
void List<T>::removeAt(const int index)
{
    if (index == 0) // если индекс = 0, то удаляем из начала - метод pop_front()
    {
        pop_front();
        return;
    }
    if (index == Size-1)   // если индекс = Size-1, то удаляем из конца - метод pop_back()
    {
        pop_back();
        return;
    }
    // при удалении из середины делаем следующее:
    int counter = 0;
    Node<T>* current = head;
    Node<T>* previous = new Node<T>();
    while (current->pNext != nullptr)
    {
        previous = current;
        current = current->pNext;
        counter++;
        if (counter == index)
        {
            previous->pNext = current->pNext;
            delete current;
            break;
        }
    }
    Size--;
}

template<typename T>
void List<T>::push_front(T data)
{
    Node<T> *temp = new Node<T>(data, head);
    head = temp;
    Size++;
}

template<typename T>
void List<T>::pop_back()
{
    Node<T>* current = head;
    Node<T>* previous = new Node<T>();
    while (current->pNext != nullptr)
    {
        previous = current;
        current = current->pNext;
    }
    previous->pNext = nullptr;
    delete current;
    Size--;
}

template<typename T>
void List<T>::pop_front()
{
    Node<T>* temp = head;
    head = head->pNext;
    delete temp;
    Size--;
}

template<typename T>
void List<T>::push_back(T data)      // добавить данный в конец списка = добавление элемента в конец списка
{
    if (head == nullptr)
    {
        head = new Node<T>(data);
    }
    else
    {
        Node<T>* current = this->head;     // временная переменная - для поиска последнего элемента одн. списка

        while (current->pNext != nullptr)    
        {
            current = current->pNext;
        }
        current->pNext = new Node<T>(data);
    }
    Size++;
}

template<typename T>
T& List<T>::operator[](const int index)
{
    int counter = 0;
    Node<T>*current = this->head;

    while (current != nullptr)
    {
        if (counter == index)
        {
            return current->data;
        }
        current = current->pNext;
        counter++;
    }
}



int main()
{
    setlocale(LC_ALL, "ru");

    List<int> lst;
    /*
    lst.push_back(5);
    lst.push_back(10);
    lst.push_back(22);
    */
    int numbersCount;
    cout << "Введите размер односвязного списка: " << endl;
    cin >> numbersCount;

    for (int i = 0; i < numbersCount; i++)
    {
        lst.push_back(rand() % 10);
    }
    
    for (int i = 0; i < numbersCount; i++)
    {
        cout << lst[i] << " ";
    }
    cout << endl;

    //cout << "Выполняю метод clear()" << endl;
    //lst.pop_front();
    //lst.clear();
    //lst.push_front(888);
    //lst.pop_back();
    lst.insert(888, 1);
    
    lst.removeAt(1);
    for (int i = 0; i < lst.GetSize(); i++)
    {
        cout << lst[i] << " ";
    }
    cout << endl;

    return 0;
}


//################################################################
/*
ВАРИАНТ СЕРГЕЯ РЕЛИЗАЦИИ МЕТОДОВ:
    void push_front(T data);
    void pop_back();
    void insert(T value, const int index);
    void removeAt(const int index);
*/
#include <iostream>
#include <string>
using namespace std;

template<typename T>
class List
{
public:
    List();
    ~List();

    void pop_front();
    void push_back(T data);
    void clear();
    void push_front(T data);
    void pop_back();
    void insert(T value, const int index);
    void removeAt(const int index);
    int GetSize(){ return Size; }
    T& operator[](const int index);

private:
    template<typename T>
    class Node
    {
    public:
        Node* pNext;      // указатель на следующий элемент типа Node
        T data;

        Node(T data=T(), Node *pNext=nullptr)     // T() - констурктор по умолчанию (лишь бы не мусор). Последн. Node указ-ет на nullptr
        {
            this->data = data;
            this->pNext = pNext;
        }
    };

    int Size;         // кол-во элементов с списке      
    Node<T> *head;    // указатель на первый элемент. Все элементы односвязного списка хранятся в динамической памяти
};

template<typename T>
List<T>::List()
{
    Size = 0;           // список при создании пуст
    head = nullptr;     // первого элемента ещё нет
}

template<typename T>
List<T>::~List()
{
    clear();
}

template<typename T>
void List<T>::clear()
{
    while (Size)
    {
        pop_front();
    }
}

template<typename T>
void List<T>::insert(T value, const int index)
{
    if (index == 0)    
    {
        push_front(value);
    }
    else
    {
        Node<T>* previous = this->head;
        for (int i = 0; i < index - 1; i++)
        {
            previous = previous->pNext;
        }
 
        previous->pNext = new Node<T>(value, previous->pNext);

        Size++;
    }
}

template<typename T>
void List<T>::removeAt(const int index)
{
    if (index == 0) 
    {
        pop_front();
    }
    else
    {
        Node<T>* previous = this->head;
        for (int i = 0; i < index - 1; i++)
        {
            previous = previous->pNext;
        }
        
        Node<T>* toDelete = previous->pNext;
        previous->pNext = toDelete->pNext;
        delete toDelete;
        Size--;
    }
}

template<typename T>
void List<T>::push_front(T data)
{
    head = new Node<T>(data, head);
    Size++;
}

template<typename T>
void List<T>::pop_back()
{
    removeAt(Size - 1);
}


template<typename T>
void List<T>::pop_front()
{
    Node<T>* temp = head;
    head = head->pNext;
    delete temp;
    Size--;
}

template<typename T>
void List<T>::push_back(T data)      // добавить данный в конец списка = добавление элемента в конец списка
{
    if (head == nullptr)
    {
        head = new Node<T>(data);
    }
    else
    {
        Node<T>* current = this->head;     // временная переменная - для поиска последнего элемента одн. списка

        while (current->pNext != nullptr)    
        {
            current = current->pNext;
        }
        current->pNext = new Node<T>(data);
    }
    Size++;
}

template<typename T>
T& List<T>::operator[](const int index)
{
    int counter = 0;
    Node<T>*current = this->head;

    while (current != nullptr)
    {
        if (counter == index)
        {
            return current->data;
        }
        current = current->pNext;
        counter++;
    }
}



int main()
{
    setlocale(LC_ALL, "ru");

    List<int> lst;
    /*
    lst.push_back(5);
    lst.push_back(10);
    lst.push_back(22);
    */
    int numbersCount;
    cout << "Введите размер односвязного списка: " << endl;
    cin >> numbersCount;

    for (int i = 0; i < numbersCount; i++)
    {
        lst.push_back(rand() % 10);
    }
    
    for (int i = 0; i < numbersCount; i++)
    {
        cout << lst[i] << " ";
    }
    cout << endl;

    //cout << "Выполняю метод clear()" << endl;
    //lst.pop_front();
    //lst.clear();
    //lst.push_front(888);
    lst.pop_back();
    //lst.insert(888, 5);
    //lst.removeAt(3);

    for (int i = 0; i < lst.GetSize(); i++)
    {
        cout << lst[i] << " ";
    }
    cout << endl;

    return 0;
}


###### vector | Библиотека стандартных шаблонов (stl) | Уроки | C++ | #1
#include <iostream>
#include <vector>
using namespace std;


int main()
{
    setlocale(LC_ALL, "ru");

    vector<int> myVector;

    cout << "Количество элементов в векторе: " << myVector.size() << endl;
    cout << "capacity вектора: " << myVector.capacity() << endl;  


    /*
    // vector<int> myVector;    // вектор - прокачанный динамический массив. Это ОБОЛОЧКА ДЛЯ ДИНАМИЧЕСКОГО МАССИВА
    // vector<int> myVector1 = { 0,484,484,999 };        // так можно инициализировать ветор аналогично массиву
    // vector<int> myVector(0);  // создать ветор на 20 элементов и инициализировать его 0-ми
    // vector<int> myVector(20,55);  // создать ветор на 20 элементов и инициализировать его 55-ми

    myVector[0] = 1000;
    
    myVector.push_back(2);
    myVector.push_back(44);
    myVector.push_back(77);
    myVector.push_back(9);

    cout << myVector.empty() << endl;   // првоерка - есть ли элементы в нашем векторе? true - когда НЕТ (vector<int> myVector(0))

    myVector.reserve(100);    // резервируем место - выставляем capacity на 100 элементов - динамический массив на 100 элементов

    myVector.capacity();  // capacity() - сколько элементов он может вместить. При доб. элем-та память выделяется с запасом
    
    myVector.shrink_to_fit();  // уменьшает capacity до размера кол-ва элементов - экономим динам. память
    cout << "shrink_to_fit()" << endl;
    cout << "Количество элементов в векторе: " << myVector.size() << endl;
    cout << "capacity вектора: " << myVector.capacity() << endl;

    myVector.pop_back();
    //myVector.clear();

    //myVector.resize(20);
    //myVector.resize(20,888);

    try
    {
        cout << myVector.at(10) << endl;     // аналогично myVector[1], но с запретом на выход за границы. НО! Он медленнее
    }
    catch (const std::out_of_range& ex)
    {
        cout << ex.what() << endl << endl;
    }

    for (int i = 0; i < myVector.size(); i++)
    {
        cout << myVector[i] << endl;
    }
    */
    return 0;
}


###### Итераторы STL | Библиотека стандартных шаблонов (stl) | Уроки | C++ | #2
#include <iostream>
#include <vector>
using namespace std;


int main()
{
    setlocale(LC_ALL, "ru");

    vector<int> myVector = { 1,9,44,422,676,78 };
vector<int>::iterator it = myVector.begin();
    
    for (vector<int>::iterator i = myVector.begin(); i != myVector.end(); i++)
    {
        cout << *i << endl;
    }

    cout << endl << "insert " << endl << endl;


    advance(it, 3);      // Перемещаем итератор. Аналог: myVector.insert((it + 3), 999);
    myVector.insert(it, 999);

    for (vector<int>::iterator i = myVector.begin(); i != myVector.end(); i++)
    {
        cout << *i << endl;
    }

    cout << endl << "erase " << endl << endl;


    vector<int>::iterator itErase = myVector.begin();
    
    // advance(itErase, 3);
    // myVector.erase(itErase);
    myVector.erase(itErase, itErase+3);   // удалить с 0 элемента по 3-й

    for (vector<int>::iterator i = myVector.begin(); i != myVector.end(); i++)
    {
        cout << *i << endl;
    }
    /*
    advance(it, 3); // если итератор не поддерживает функционал: *(it + 3)
    cout << *it << endl;

    for (vector<int>::reverse_iterator i = myVector.rbegin(); i != myVector.rend(); i++)    //  reverse_iterator, rbegin(), rend() - справа налево
    {
        cout << *i << endl;
    }

    for (vector<int>::iterator i = myVector.begin(); i != myVector.end(); i++)
    {
        cout << *i << endl;
    }

    for (vector<int>::const_iterator i = myVector.cbegin(); i != myVector.cend(); i++)   // const_iterator, cbegin(), cend() - константные методы
    {
        cout << *i << endl;
    }
    // myVector.end() - указаывает на следующий элемент контейнера после последнего, то есть вникуда
    // vector<int>::iterator it;    // создаём итератор it вектора с данными int
    // it = myVector.begin();  // метод begin() возвращает итератор нужного нам типа
    // *it = 1000;
    // cout << *it << endl;     // разыменовываем итератор. Так же как с указателями и умными указателями   

    
    // int arr[] = { 2,6,9 };          // обычный статический массив
    // cout << arr[1] << endl;         // доступ к элементу массива через оператор []
    // cout << *(arr + 1) << endl;     // арифметика указателей
    */

    return 0;
}


###### Ключевое слово auto | Изучение С++ для начинающих. Урок #136
#include <iostream>
#include <vector>
//using namespace std;


int main()
{
    setlocale(LC_ALL, "ru");
    
    std::vector<int> myVector = { 11,46,9 };   // если не включено: using namespace std;

    std::vector<int>::iterator it = myVector.begin();
    auto it2 = myVector.begin();   // вместо std::vector<int>::iterator it2 = myVector.begin();

    for (auto it = myVector.begin(); it != myVector.end(); it++)
    {
        std::cout << *it << std::endl;
    }

    /*
    auto a = 10;   // С ПРОСТЫМИ ТИПАМИ ДАННЫХ ЛУЧШЕ НЕ ИСПОЛЬЗОВАТЬ auto - усложн. читабельность кода
    auto b = 1.44;
    auto c = "string";
    auto d = true;
    */

    return 0;
}


###### LIST | STL C++ | Библиотека стандартных шаблонов (stl) | Уроки | C++ | #3
#include <iostream>
#include <vector>
#include <list>
using namespace std;

template<typename T>
void PrintList(const list<T> &lst)
{
    for (auto i = lst.cbegin(); i != lst.cend(); ++i)    // префиксный инкремент !!!
    {
        cout << *i << endl;
    }
};


template<typename T>
void Advance(T &it, const int index)
{   // My realisation of function advance
    for (int i = 0; i < index; ++i)
    {
        ++it;
    }
};



int main()
{
    setlocale(LC_ALL, "ru");
    
    list<int> myList = { 15,64,979,54,99 };

    list<int> myList2 = { 22,45,554 };
    
    PrintList(myList);
    
    // myList.assign(myList2.begin(), myList2.end());   // Копирование из myList2 в myList
    // myList.assign(3, 111); // заполн. лист к.-то элем-ми (111). НО, прежде чем заполн. лист этими элем-ми, он ВСЕ предыд. элементы удаляет
    // myList.size();
    // myList.remove(979);    // удалить элемент номиналом 979
    // myList.erase(it);   // удалить элемент в позиции итератора it

    // auto Iter = myList.begin();
    // Advance(Iter, 3);   // моя релизация функции advance
    // cout << *Iter;

    // ++it;     // ИТЕРАТОР ЛИСТА НЕ ПОДДЕРЖИВАЕТ ДОСТУП К ПРОИЗВОЛЬНОМУ ИНДЕКСУ, например: it += 2
    // advance(it, 3);     // на какое количество сдвинуть итератор
    // myList.insert(it, 111);
    // myList.clear();
    // myList.reverse();
    // myList.unique();  // { 99,15,64,99,979,54,99,99,99 } ---> { 99,15,64,99,979,54,99 }
    // myList.push_back(5);
    // myList.push_front(151);
    // cout << myList.size();
    // PrintList(myList);
    // myList.pop_back();
    // myList.pop_front();
    // myList.sort();
    // auto it = myList.begin(); // list<int>::iterator it = myList.begin();

    return 0;
}


###### Итераторы stl c++ | prefix vs postfix | Библиотека стандартных шаблонов (stl) | Уроки | C++ | #4     
#include <iostream>
#include <vector>
#include <list>
using namespace std;

template<typename T>
void PrintList(const list<T> &lst)
{
    for (auto i = lst.cbegin(); i != lst.cend(); ++i)    // префиксный инкремент !!!
    {
        cout << *i << endl;
    }
};

int main()
{
    setlocale(LC_ALL, "ru");
    
    list<int>::iterator it;

    it++;    // F12 - показать перегруженную реализацию оператора

    ++it;

    return 0;
}


###### Цикл foreach C++ | range-based циклы | Изучение С++ для начинающих. Урок #137

#include <iostream>
#include <vector>      
#include <list>
using namespace std;

template<typename T>
void PrintList(const list<T>& lst)
{   // Ф-ия печати элементов списка. Реализация через range-base цикл
    for (const auto element : lst)                 
    {
        cout << element << endl;
    }

    /*
    for (auto i = lst.cbegin(); i != lst.cend(); ++i)
    {
        cout << *i << endl;
    }
    */
};

int main()
{
    setlocale(LC_ALL, "ru");
    
    list<int> myList = { 1,99,4,94,799,44,6 };

    for (const auto element : myList)
    {
        cout << element << endl;
    }

    cout << endl << endl;

    PrintList(myList);

    /*
    int arr[] = { 5,11,94,99,44 };
    for (auto &element : arr)     // RANGE-BASE ЦИКЛ. Удобно использовать ключевое слово auto
    {
        cout << element << endl;
        element += 1;
    }

    cout << endl << endl;
    for (const auto& element : arr)     // лучше передавать по ссылке, чтобы не копировать данные. const - не получится изменить элемент
    {
        cout << element << endl;
    }
    */

    return 0;
}


###### forward list stl c++ | Библиотека стандартных шаблонов (stl) | Уроки | C++ | #5
#include <iostream>
#include <forward_list>
using namespace std;

// FORWARD-LIST - реализация односвязного списка. Обычный LIST - двусвязного

int main()
{
    setlocale(LC_ALL, "ru");
    
    forward_list<int> fl = { 131,94,494 };

    forward_list<int>::iterator it = fl.begin();



    cout << *it << endl << endl;

    for (auto& element : fl)
    {
        cout << element << endl;
    }

    // auto it = fl.before_begin();      // итератор, кот. указывает на НИЧТО перед началом. Поэтому можно исп-ть insert_after() для элемента 0
    // auto it = fl.cbefore_begin();
    // fl.erase_after(it);
    // forward_list<int>::iterator it = fl.begin();
    // fl.insert_after(it, 9999);
    // ++it;
    // fl.push_front(1);

    /*
    for (auto &element : fl)
    {
        cout << element << endl;
    }
    */

    return 0;
}


###### array STL C++ | | Библиотека стандартных шаблонов (stl) | Уроки | C++ | #6
#include <iostream>
#include <array>
using namespace std;

// STL array - обёртка для СТАТИЧЕСКИХ массивов 

int main()
{
    setlocale(LC_ALL, "ru");
    
    array<int,4> arr = { 1,94,77,9};     // в скобках <> - тип элементов и размер массива 
    
    for (auto element : arr)
    {
        cout << element << endl;
    }

    /*
    for (int i = 0; i < arr.size(); i++)
    {
        cout << arr[i] << endl;
    }
    */

    /*
    try
    {
        cout << arr.at(11) << endl;
    }
    catch (const std::exception&ex)
    {
        cout << ex.what() << endl;
    }
    */

    // arr.front();   // доступ к 0-му элементу массива
    // arr.back();    // доступ к последнему элементу массива
    // arr.fill(-1);    // заполнит массив значенями -1
    // arr.size();   // не нужно хранить размер массива в отдельной переменной. Для этого есть метод size()
    // cout << arr[0] << endl;        // не контролируется на выход за границы массива
    // cout << arr.at(0) << endl;     // проверка на выход за границы массива
    return 0;
}


###### Контейнеры STL и операторы сравнения. | Библиотека стандартных шаблонов (stl) | Уроки | C++ | #7
#include <iostream>
#include <array>
using namespace std;

// При сравнении контейнеров элементы контейнера STL должны иметь возможность исп. операторы сравнения

int main()
{
    setlocale(LC_ALL, "ru");
    
    array<int, 4> arr = { 1,94,77,4 };  
    array<int, 4> arr2 = { 1,94,77,9 };

    // bool result = arr < arr2;
    bool result = arr != arr2;

    cout << result << endl;

    return 0;
}


###### deque stl c++ | Библиотека стандартных шаблонов (stl) | Уроки | C++ | #8
#include <iostream>
#include <vector>
#include <deque>
using namespace std;

// deque - гибрит ветора (~динамического массива) и листа (двусвязного списка)

int main()
{
    setlocale(LC_ALL, "ru");

    deque<int> dq = { 1,9,94 };

    deque<int>::iterator it = dq.begin();    // итератор произвольного доступа - вправо и влево можно двигаться
    ++it;                                
    --it;

    // dq.push_front(888);
    // dq.push_back(888);
    // dq[0];
    // dq.at(0);

    return 0;
}


###### SET | MULTISET | Ассоциативные контейнеры | Библиотека стандартных шаблонов (stl) | Уроки | C++ #9
#include <iostream>
#include <set>
using namespace std;

// Контейнеры set и multiset основаны на бинарном дереве. Упорядоченная структура данных. Хранит уникальные значения

int main()
{
    setlocale(LC_ALL, "ru");
    
    multiset<int> myMultiset = { 1,66,1,16,99,48 };   // может хранить несколько одинаковых значений

    myMultiset.insert(1);
    myMultiset.insert(1);
    myMultiset.insert(1);

    auto it1 = myMultiset.lower_bound(1);     // аналог метода find(), возвращает первый элемент со значением 1 в коллекции
    auto it2 = myMultiset.upper_bound(1);     // возвращает итератор на следующий элемент после последнего значения 1, т.е. 16
    auto a = myMultiset.equal_range(1);       // возвращает диапазон чисел от upper_bound(), до lower_bound(), т.е. (1, 16)


    cout << endl << endl;
    for (auto& item : myMultiset)
    {
        cout << item << endl;
    }


    /*
    for (auto &item : mySet)
    {
        cout << item << endl;
    }
    */

    // auto result = mySet.erase(11);   // возвращает 0 или 1 size_t - unsigned int (не может хранить отрицательные числа). 
    // auto result2 = mySet.insert(64); // возрващает пару значений - итератор на число (добавленное или уже имеющееся), и true, если элемент удалось ставить, false - если элемент уже был добавлен 
    // mySet.erase(11);        

    /*
    int value;
    cin >> value;

    if (mySet.find(value) != mySet.end())
    {
        cout << "Number " << value << " is found!" << endl;
    }
    else
    {
        cout << "Number " << value << " is not found!" << endl;
    }
    */

    // auto it = mySet.find(10);   // метод find() возвращает итератор на найденный момент в set'е, если найдёт. Если не найдёт - вернёт итератор на mySet.end()
    /*
    set<int> mySet = { 1,44,6,-2,43 };
    mySet.insert(5);            // первый элемент будет в корне дерева
    mySet.insert(1);            // меньше 5 - в левую часть дерева
    mySet.insert(12);           // больше 5 - в правую часть дерева
    mySet.insert(4);
    mySet.insert(4);
    mySet.insert(4);
    mySet.insert(4);
    mySet.insert(-1);
    */

    return 0;
}


###### typedef c++ что это | Изучение С++ для начинающих. Урок #138
#include <iostream>
#include <vector>
typedef std::vector<int> int_vector;
typedef std::vector<float> float_vector;

int main()
{
    setlocale(LC_ALL, "ru");

    std::vector<int> myVector1;

    int_vector myVector2;
    
    float_vector myVector3;

    return 0;
}


###### MAP | MULTIMAP | Ассоциативные контейнеры | Библиотека стандартных шаблонов (stl) | Уроки | C++ #10
#include <iostream>
#include <string>
#include <map>
using namespace std;


int main()
{
    setlocale(LC_ALL, "ru");

    multimap<string, int> myMultimap;    
    // У типа multimap не перегружен оператор [] и метод at() !!!
    myMultimap.emplace("Петя", 1313);
    myMultimap.emplace("Маша", 222);
    myMultimap.emplace("Миша", 4441);

    myMultimap.emplace("Петя", 1000);    // можно добавлять повторные элементы

    auto res = myMultimap.find("Петя");

    for (auto element : myMultimap)
    {
        cout << element.first << "\t" << element.second << endl;
    }
    
    /*
    map<string, int> myMap;
   
    myMap.emplace("Петя", 1313);
    myMap.emplace("Маша", 222);
    myMap.emplace("Миша", 4441);

    myMap["Петя"] = 99;     // МЕНЯЕТ значение по ключу
    myMap["Вася"] = 9797;   // СОЗДАЁТ новый элемент

    myMap.at("Петя") = 3;    // работает по ключу. Если ключа нет в map - будет вызвано ИСКЛЮЧЕНИЕ

    myMap.erase("Петя");
    */

    /*
    myMap.insert(make_pair(11, "Телефон"));   // метод insert принимает пару. Поэтому можно сделать так: make_pair(key, value)
    myMap.insert(pair<int, string>(2, "Ноутбук"));  // метод insert принимает пару. Поэтому можно сделать руками pair<key_type, value_type>(key, value)
    myMap.emplace(3, "Монитор");    // начиная с 11-й версии С++. Метод insert() копирует иил перемещает объект. А метод emplace() просто создаёт
    myMap.emplace(22, "Клавиатура");
    myMap.emplace(22, "TEST");   // Не добавит пару, елси такой ключ уже имеется в коллекции !!!

    auto res = myMap.emplace(22, "TEST"); // метод emplace() возвращает пару, вторым значением которой будет true, если удалось добавить элемент
    cout << res.second << endl;

    cout << myMap[3];         // перегружен оператор []
    */

    /*
    int key = 22;
    auto it = myMap.find(key);    // если на находит, возвращает myMap.end()

    if (it != myMap.end())
    {
        cout << it->first << endl;
        cout << it->second << endl;
    }
    else
    {
        cout << "Key " << key << " is not found in the map: " << endl;
        for (pair<int, string> element : myMap)
        {
            cout << element.first << "\t" << element.second << endl;
        }
    }
    */

    // std::pair<int, string> p(1, "телефон");     // пара с ключом типа int и занчением типа string
    // pair<string, string> p("1111p", "телефон");  
    // cout << p.first << endl;
    // cout << p.second << endl;
    // map<int, string> myMap;    // для своего типа данных в типе ключа нужно перегрузить оператор сравнения, чтобы корректно строилось бинарное дерево
    // map<myClass, string> myMap;    // для своего типа данных в типе ключа нужно перегрузить оператор сравнения, чтобы корректно строилось бинарное дерево

    return 0;
}


###### Многопоточность | Потоки | thread | Многопоточное программирование | Уроки | C++ #1
#include <iostream>
#include <thread>      // для работы с потоками
#include <chrono>      // для работы со временем 
using namespace std;

void DoWork()
{

    for (int i = 0; i < 10; i++)
    {
        cout << "ID потока = " << this_thread::get_id() << "\tDoWork\t" << i << endl;
        this_thread::sleep_for(chrono::milliseconds(1000));
    }
}

int main()
{
    setlocale(LC_ALL, "ru");

    thread th(DoWork);             // передаём указатель на функцию. Имя функции = укзатель на функцию
    // th.detach();     // отсоединит поток th после выполнения основного потока (main)
    thread th2(DoWork);

    for (int i = 0; i < 10; i++)
    {
        cout << "ID потока = " << this_thread::get_id() << "\tmain\t" << i << endl;
        this_thread::sleep_for(chrono::milliseconds(500));
    }

    th.join();    // !!! БЛОКИРУЕТ ОСНОВНОЙ ПОТОК ДО ВЫПОЛНЕНИЯ ПОТОКА th !!! Вызывать нужно в том месте кода, где вы хотите дождаться выполнения потока th. Например, в конце main()
    th2.join();
    // thread th(DoWork);             // передаём указатель на функцию. Имя функции = укзатель на функцию
    // th.detach();     // отсоединит поток th после выполнения основного потока (main) 

    // this_thread::sleep_for(chrono::milliseconds(3000));          // приостанавливает работу текущего потока на определённое время
    // cout << this_thread::get_id() << endl;                   // получить идентификатор потока
    // th.join();    // !!! вызывать нужно в том месте кода, где вы хотите дождаться выполнения потока. Например, в конце main()

    return 0;
}


###### Stack | Адаптеры контейнеров | Библиотека стандартных шаблонов (stl) | Уроки | C++ #11
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <stack>
using namespace std;

// Адаптеры контейнеров - ограничивают функционал контейнера в соответствии с адаптером
// Стек даёт доступ только к последнему элементу - LIFO

int main()
{
    setlocale(LC_ALL, "ru");

    stack<int, list<int>> st;
    
    st.push(2);  
    st.push(43);
    st.push(3);
    st.emplace(9);
    

    while (!st.empty())     // empty() - вернёт true, когда стек будет пустым
    {
        cout << st.top() << endl;
        st.pop();
    }

    /*
    stack<int> st; 
        
    st.push(2);      // создаёт копию объекта и помещает объект в стек
    st.push(43);
    st.push(3);
    st.emplace(9);   // создаёт объект и помещает в стек непосредственно в коллекции без копирования и перемещения

    while (!st.empty())     // empty() - вернёт true, когда стек будет пустым
    {
        cout << st.top() << endl;
        st.pop();
    }
    */
    
    // st.push(2);      // создаёт копию объекта и помещает объект в стек
    // st.emplace(9);   // создаёт объект и помещает в стек непосредственно в коллекции без копирования и перемещения
    // st.top();        // возвращает ссылку на послдений элемент. Который является первым на извлечение - по приницпу стека (LIFO)
    // st.size();
    // st.pop();        // извлекат последний элемент по принципо LIFO

    return 0;
}


###### Потоки с параметрами | Многопоточное программирование | Уроки | C++ #2
#include <iostream>
#include <string>
#include <thread>
#include <chrono>
using namespace std;

void DoWork(int a, int b, string msg)
{
    cout << msg << endl;
    this_thread::sleep_for(chrono::milliseconds(3000));
    cout << "========\t" << "DoWork is STARTED\t========" << endl;
    this_thread::sleep_for(chrono::milliseconds(5000));
    cout << "a + b = " << a + b << endl;
    this_thread::sleep_for(chrono::milliseconds(3000));
    cout << "========\t" << "DoWork is STOPPED\t========" << endl;
}


int main()        // главный поток - поток пользовательского интерфейса - UI-thread
{
    setlocale(LC_ALL, "ru");
    
    thread th(DoWork,2,3,"Hello World!");          // типы параметров и их количество должно соответствовать тем параметрам, которые принимает функция

    for (size_t i = 0; true; i++)
    {
        cout << "ID потока = " << this_thread::get_id() << "\tmain works\t" << i << endl;
        this_thread::sleep_for(chrono::milliseconds(500));
    }

    th.join();

    return 0;
}


###### queue | priority queue | Адаптеры контейнеров | Библиотека стандартных шаблонов (stl) | C++ #12
#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <queue>
using namespace std;


// queue, priority_queue - адаптеры контейнеров, ограничивающий контейнер очередью - FIFO 
// queue может работать только с list и с deque, но не с vector
// priority_queue позволяет упорядочить данные в очереди
// priority_queue queue может работать только с vector и с deque, но не с list
// priority_queue - в STL элементы добавляются в очередь сразу согласно приоритету. Чем > значение, тем выше приоритет

int main() 
{
    setlocale(LC_ALL, "ru");
    
    priority_queue<int> q;

    q.emplace(56);
    q.emplace(4);
    q.emplace(7);
    q.emplace(99);
    
    cout << "elements count " << q.size() << endl;
    while (!q.empty())
    {
        cout << q.top() << endl;
        q.pop();
        cout << "elements count " << q.size() << endl;
    }

    // priority_queue<int,vector<int>> q;  
    // q.top();       // для priority_queue - посмотреть первый элемент в очереди. Последний посмотреть не можем

    // queue<int,list<int>> q;
    // q.front();      // доступ к первому добавленному элементу в очереди
    // q.back();       // доступ к последнему добавленному элементу в очереди - получаем ссылку на него
    // q.push(22);     // скопировать элемент и добавить его в очередь 
    // q.emplace(1);   // создать элемент и сразу добавить его в очередь q
    // q.pop();        // удаляет из очереди согласано принципу FIFO
    // q.size();

    /*
    queue<int> q2;

    for (size_t i = 0; i < 10; i++)
    {
        q2.emplace(rand() % 10);
    }
    q.swap(q2);       // обмен содержимым одного адаптера с другим таким же адаптером   

    while(!q.empty())
    {
        cout << q.front() << endl;
        q.pop();
    }
    */

    return 0;
}


###### Многофайловый проект | Изучение С++ для начинающих. Урок #139
// ########## FILE main.cpp ##########
#include <iostream>
#include "Sum.h"    // двойные кавычки означают, что программа будет искать файл прямо среди файлов нашего проекта
/*
Подключение #include "Sum.h" означает на выходе (всё содрежимое файла Sum.h):
#pragma once
int Sum(int a, int b);
*/
#include "MyClass.h"
using namespace std;
using namespace myNamespace;

int main() 
{
    setlocale(LC_ALL, "ru");

    myNamespace::MyClass m;
    char str[] = "Hello World!!!";
    m.PrintMessage(str);    // F12 - перейти на реализацию метода

    /*
    int result = Sum(90, 15);
    cout << result << endl;
    */
    return 0;
}


// ########## FILE Sum.h ##########
#pragma once       // защита от повторного включения
int Sum(int a, int b);


// ########## FILE Sum.cpp ##########
#include "Sum.h"

int Sum(int a, int b)
{
    return a + b;
}


// ########## FILE MyClass.h ##########
#pragma once
#include <iostream>

// В файле header описываются прототипы методов класса - чтобы было ясно, что вообще класс делает

namespace myNamespace
{
    class MyClass
    {
    public:
        void PrintMessage(char str[]);
    };
}


// ########## FILE MyClass.cpp ##########
#include "MyClass.h"

namespace myNamespace 
{ 
    void MyClass::PrintMessage(char str[])
    {
        std::cout << str << std::endl;
    }
}


###### Многофайловый проект | Защита от повторного включения | Изучение С++ для начинающих. Урок #140
// ########## FILE main.cpp ##########
#include <iostream>
using namespace std;

int main()
{
    setlocale(LC_ALL, "ru");

    return 0;
}


// ########## FILE Bar.h ##########
// "#pragma once" - директива защиты от повторного включения. НО, работает не во всех компилляторах
// Вместо директивы "#pragma once" реализовывают условную компилляцию:
// Но лучше использовать и "#pragma once", и условную компилляцию

#pragma once   

#ifndef _BAR_H_   // Если НЕ определено _BAR_H_, т.е. не подключен ещё Bar.h, то выполнить тело условного оператора

#define _BAR_H_

#include "Foo.h"

void Bar();

#endif // !_BAR_H_


// ########## FILE Bar.cpp ##########
#include "Bar.h"

void Bar()
{
}


// ########## FILE Foo.h ##########
#pragma once   // можно использовать и "#pragma once", и условную компилляцию

#ifndef _FOO_H_

#define _FOO_H_

#include "Bar.h"

void Foo();

#endif // !_FOO_H_


// ########## FILE Foo.cpp ##########
#include "Foo.h"

void Foo()
{
}


###### Возврат результата из потока по ссылке | Многопоточное программирование | Уроки | C++ #3
#include <iostream>
#include <string>
#include <thread>
#include <chrono>
using namespace std;

void DoWork(int &a)
{
    this_thread::sleep_for(chrono::milliseconds(2000));

    cout << "ID потока = " << this_thread::get_id() << " ========\tDoWork is STARTED\t========" << endl;

    this_thread::sleep_for(chrono::milliseconds(5000));

    a *= 2;

    cout << "ID потока = " << this_thread::get_id() << " ========\tDoWork is STOPPED\t========" << endl;
}


int main()
{
    setlocale(LC_ALL, "ru");

    int q = 5;

    thread t(DoWork, std::ref(q));        // !!! только так можно по ссылке предвать переменную в поток
     
    for (size_t i = 0; i < 10; i++)
    {
        cout << "ID потока = " << this_thread::get_id() << "\tmain works\t" << i << endl;
        this_thread::sleep_for(chrono::milliseconds(500));
    }
   
    t.join();              // основной поток ждёт поток t
    cout << q << endl;

    return 0;
}


###### Union | Использование в С++ | Изучение С++ для начинающих. Урок #141
#include <iostream>
using namespace std;

// union - позволяет делить (расшаривать) одну и ту же область паямти под разные данные.
// union выделяет под общие нужды между теми типами, что у него есть, то количество 
// памяти, которое требуется для самой большой переменной

union MyUnion
{
    short int a;
    int b;
    float c;
};


int main()
{
    setlocale(LC_ALL, "ru");
    
    MyUnion u;

    u.a = 5;
    u.b = 40000;
    u.c = 43.54;

    return 0;
}


###### std::function | Полиморфная обёртка функции | Изучение С++ для начинающих. Урок #142
#include <iostream>
#include <functional>
#include <vector>
using namespace std;

// std::function - аналогично указателям на функцию, но в формате ООП

void Foo(int a)
{
    if (a > 10 && a < 40)
    {
        cout << "Foo() --> " << a << endl;
    }
}

void Bar(int a)
{
    if (a % 2 == 0)
    {
        cout << "Bar() --> " << a << endl;
    }
}

void Baz(int a)
{
    cout << "Baz()" << endl;
}

void DoWork(vector<int>& vc, vector<function<void(int)>> funcVector)    // передать коллекцию функций
{
    for (auto el : vc)
    {
        for (auto &fel : funcVector)
        {
            fel(el);
        }
    }
}


/*
void DoWork(vector<int>& vc, std::function<void(int)> f)
{
    for (auto el : vc)
    {
        f(el);
    }
}
*/

/*
int Sum(int a, int b)
{
    return a + b;
}
*/

int main()
{
    setlocale(LC_ALL, "ru");

    vector<int> vc = { 1,51,4,10,44,98,8,12,22,29,49 };

    vector<function<void(int)>> fVector;
    
    fVector.emplace_back(Foo);
    fVector.emplace_back(Bar);
    fVector.emplace_back(Baz);

    DoWork(vc, fVector);

    /*
    DoWork(vc, Bar);
    cout << endl << endl;
    DoWork(vc, Foo);
    */

    /*
    function<void()> f;   
    f = Foo;
    f();
    f = Bar;
    f();
    
    function<int(int,int)> f2;
    f2 = Sum;
    cout << f2(90, 15) << endl;
    */

    return 0;
}


###### Лямбда-выражения | Лямбда функции | Анонимные функции | Изучение С++ для начинающих. Урок #143
#include <iostream>
#include <functional>
#include <vector>
using namespace std;



void Foo(int a)
{
    if (a > 10 && a < 40)
    {
        cout << "Foo() --> " << a << endl;
    }
}

void Bar(int a)
{
    if (a % 2 == 0)
    {
        cout << "Bar() --> " << a << endl;
    }
}

void Baz(int a)
{
    cout << "Baz()" << endl;
}

void DoWork(vector<int>& vc, function<void(int)> func)
{
    for (auto el : vc)
    {
        func(el);
    }
}

/*
void DoWork(vector<int>& vc, vector<function<void(int)>> funcVector)
{
    for (auto el : vc)
    {
        for (auto &fel : funcVector)
        {
            fel(el);
        }
    }
}
*/

int main()
{
    setlocale(LC_ALL, "ru");

    auto f = [](int a, int b)    // тип функции определяется типом возвращаемого значения автоматически !!!
    {
        return a + b;    // тип функции определяется типом возвращаемого значения автоматически !!!
        // return 1.;
        // return true;
    };

    auto q = f(2, 5);

    /*
    int p = 0;

    auto f = [&p]()      // начиная с 14-й версии C++ можно использовать auto, а не только function<void(int)>
    {                 
        p = 5;
    };

    f();
    */

    /*
    [&p](int a)    // lambda-функция изолирована от всего внешнего контекста. [] позволяют использовать то, 
    {                       // что РЯДОМ с lambda-функцией, то есть это оператор захвата из внешнего контекста
        p = 5;
    };
    */


    /*
    function<void(int)> f;

    f = [](int a) 
    {
        cout << "Вызвана анонимная функция с параметром - " << a << endl;
    };
    */

    /*
    vector<int> vc = { 1,51,4,10,44,98,8,12,22,29,49 };
    DoWork(vc, [](int a){ cout << "Вызвана анонимная функция с параметром - " << a << endl; });

    DoWork(vc, [](int a)
        {
            if (a % 2 == 0)
            {
                cout << "lambda --> " << a << endl;
            }
        });
    */

    return 0;
}


###### Лямбда выражения и возврат результата выполнения потока | Многопоточное программирование | C++ #4
#include <iostream>
#include <chrono>
#include <thread>
using namespace std;

int Sum(int a, int b)
{
    this_thread::sleep_for(chrono::milliseconds(2000));

    cout << "ID потока = " << this_thread::get_id() << " ========\tSum STARTED\t========" << endl;

    this_thread::sleep_for(chrono::milliseconds(5000));

    cout << "ID потока = " << this_thread::get_id() << " ========\tSum STOPPED\t========" << endl;

    return a + b;
}

int main()
{
    setlocale(LC_ALL, "ru");

    int result;
    // thread t([&result](int a, int b) { result = a + b; }, 2, 5);
    thread t([&result]() { result = Sum(2, 5); });
    
    for (size_t i = 1; i <= 10; i++)
    {
        cout << "ID потока = " << this_thread::get_id() << "\tmain works\t" << i << endl;
        this_thread::sleep_for(chrono::milliseconds(500));
    }

    t.join();

    cout << "Sum results = " << result << endl;

    return 0;
}


###### Захват контекста лямбдой | Лямбда функции | Лямбда-выражения | Анонимные функции | Урок #144
#include <iostream>
using namespace std;

class MyClass
{
public:
    int a = 11;

    void Msg()
    {
        cout << "msg" << endl;
    }

    void Lambda()
    {
        auto f = [this]()   // this - захватывает сразу весь объект класса (даёт доступ ко всем полям класса)
        {
            this->Msg();
        };
        f();
    }
};



int main()
{
    setlocale(LC_ALL, "ru");

    auto f = []()->float    // синтаксис []()->float{} определяет жёстко тип ВОЗВРАЩАЕМОГО ЗНАЧЕНИЯ float
    {
        return 1.;
    };

    auto result = f();
    cout << result << endl;

    /*
    MyClass m;
    m.Lambda();
    */
    
    // auto f = [a, b]()mutable {};

    // auto f = [&a, b]()mutable {};

    /*
    auto f = [=]()mutable     // = вместе с mutable позволяют передавать все переменные по значению, то есть копии
    {
        cout << a << endl;
        a = 1313;
        cout << b << endl;
        b = 11;
    };
    */

    /*
    auto f = [&]() // символ & означает, что мы передаем в lambda-функцию все переменные ПО ССЫЛКЕ
    {
        cout << a << endl;
        a = 1313;
        cout << b << endl;
        b = 11;
    };
    */

    /*
    auto f = [=]() // символ = означает, что мы передаем в lambda-функцию все переменные ПО ЗНАЧЕНИЮ, НО только ДЛЯ ЧТЕНИЯ
    {
       cout << a << endl;
       cout << b << endl;
    };
    */

    /*
    auto f = [&a, b]()
    {
        cout << a << endl;
        a = 1313;
        cout << b << endl;
    };
    */

    /*
    auto f = [a]()     // захват по параметру, ТОЛЬКО ДЛЯ ЧТЕНИЯ !!!
    {
        cout << a << endl;   
    };

    f();
    */
    return 0;
}


###### Как измерить время выполнения кода | Изучение С++ для начинающих. Урок #145
#include <iostream>
#include <thread>       // библиотека <chrono> подключается автоматически вместе с библиотекой <thread>
using namespace std;

class SimpleTimer
{
public:
    SimpleTimer()
    {
        start = std::chrono::high_resolution_clock::now();
    }
    ~SimpleTimer()
    {
        end = std::chrono::high_resolution_clock::now();
        std::chrono::duration<float> duration = end - start;
        cout << "DURATION: " << duration.count() << "s" << endl;
    }
private:
    std::chrono::time_point<std::chrono::steady_clock> start, end;
};



int Sum(int a, int b)
{
    SimpleTimer st;

    this_thread::sleep_for(chrono::milliseconds(2000));

    cout << "ID потока = " << this_thread::get_id() << " ========\tSum STARTED\t========" << endl;

    this_thread::sleep_for(chrono::milliseconds(5000));

    cout << "ID потока = " << this_thread::get_id() << " ========\tSum STOPPED\t========" << endl;

    return a + b;
}

void Foo()
{
    SimpleTimer st;
    for (size_t i = 0; i < 5000; i++)
    {
        cout << i << endl;
    }
}


int main()
{
    Foo();
    
    
    SimpleTimer st;
    setlocale(LC_ALL, "ru");
    int result;
    thread t([&result]() { result = Sum(2, 5); });

    for (size_t i = 0; i < 10; i++)
    {
        cout << "ID потока: " << std::this_thread::get_id() << "\tmain works\t" << i << endl;
        std::this_thread::sleep_for(chrono::milliseconds(500));
    }

    t.join();

    cout << "Sum result = " << result << endl;


    /*
    auto start = chrono::high_resolution_clock::now();
    setlocale(LC_ALL, "ru");
    int result;
    thread t([&result]() { result = Sum(2, 5); });
    for (size_t i = 0; i < 10; i++)
    {
        cout << "ID потока: " << std::this_thread::get_id() << "\tmain works\t" << i << endl;
        std::this_thread::sleep_for(chrono::milliseconds(500));
    }
    t.join();
    cout << "Sum result = " << result << endl;
    auto end = chrono::high_resolution_clock::now();

    chrono::duration<float> duration = end - start;
    cout << "Duration: " << duration.count() << "s" << endl;
    */
    return 0;
}


###### Функторы в с++ | Что такое функтор | Изучение С++ для начинающих. Урок #146
#include <iostream>
using namespace std;

class MyFunctor
{
public:
    int operator ()(int a, int b)
    {
        cout << "Я функтор " << endl;
        return a + b;
        // cout << "Я функтор " << count << endl;
        // ++count;
    }
    
private:
    // int count = 0;
};

class EvenFunctor
{
public:
    void operator ()(int value) 
    {
        if (value % 2 == 0)
        {
            evenSum += value;
            ++evenCount;
        }
    }

    void ShowEvenSum()
    {
        cout << "Сумма чётных чисел: " << evenSum << endl;
    }

    void ShowEvenCount()
    {
        cout << "Количество чётных чисел: " << evenCount << endl;
    }
    
private:
    int evenSum = 0;
    int evenCount = 0;
};



int main()
{
    setlocale(LC_ALL, "ru");

    int arr[] = { 1,2,55,99,44,3,6 };
    EvenFunctor ef;

    for (auto element : arr)
    {
        cout << element << endl;
        ef(element);
    }

    ef.ShowEvenCount();
    ef.ShowEvenSum();

    /*
    MyFunctor f;
    int result = f(2, 5);
    cout << result << endl;
    */

    return 0;
}


###### Предикаты с++ | Что такое предикат | Изучение С++ для начинающих. Урок #147
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
using namespace std;

class Person
{
public:
    Person(string name, double score)
    {
        this->Name = name;
        this->Score = score;
    }

    bool operator ()(const Person &p)
    {
        return p.Score > 180;
    }

    string Name;
    double Score;
};

bool GreaterThanZero(int a)
{
    return a > 0;
}

bool LessThanZero(int a)
{
    return a < 0;
}

int main()
{
    setlocale(LC_ALL, "ru");

    vector<Person> people
    {
        Person("Вася",181),
        Person("Петя",30),
        Person("Маша",179),
        Person("Даша",200),
        Person("Катя",198),
        Person("Андрей",181),
        Person("Сергей",50),
        Person("Иван",150),
        Person("Иван",190)
    };

    int result = count_if(people.begin(), people.end(), people.front());

    cout << result << endl << endl;

    for (auto el : people)
    {
        cout << Person("",0)(el) << endl;
    }

    /*
    vector<int> v = { 1,-2,-55,9,-3,8,2 };

    int result = count_if(v.begin(), v.end(), GreaterThanZero);
    cout << result << endl;

    result = count_if(v.begin(), v.end(), LessThanZero);
    cout << result << endl;
    */
    return 0;
}


###### STL Алгоритмы сортировки | Бинарный предикат | Лямбда функции | C++ STL Уроки | #13
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
using namespace std;

class Person
{
public:
    Person(string name, double score)
    {
        this->Name = name;
        this->Score = score;
    }

    bool operator ()(const Person &p)
    {
        return p.Score > 180;
    }

    string Name;
    double Score;
};

bool GreaterThanZero(int a)
{
    return a > 0;
}

bool LessThanZero(int a)
{
    return a < 0;
}

/*
bool MyPred(int a, int b)
{
    return a < b;
}
*/

int main()
{
    setlocale(LC_ALL, "ru");


    vector<Person> people
    {
        Person("Вася",181),
        Person("Петя",30),
        Person("Маша",179),
        Person("Даша",200),
        Person("Катя",198),
        Person("Андрей",181),
        Person("Сергей",50),
        Person("Иван",150),
        Person("Иван",190),
        Person("Петя",10)
    };

    for (auto element : people)
    {
        cout << "Имя:\t" << element.Name << "\tБаллы:\t" << element.Score << endl;
    }

    cout << endl << endl;

    // sort(people.begin(), people.end(), [](const Person& p1, const Person& p2) { return p1.Score > p2.Score; });
    sort(people.begin(), people.end(), [](const Person& p1, const Person& p2) { return p1.Name < p2.Name; });

    for (auto element : people)
    {
        cout << "Имя:\t" << element.Name << "\tБаллы:\t" << element.Score << endl;
    }

    /*
    const int SIZE = 7;
    int arr[SIZE] = { 9,4,94,6,1,3,7 };

    for (auto element : arr)
    {
        cout << element << endl;
    }

    cout << endl << endl;
    sort(arr, arr + SIZE, [](int a, int b) { return a < b; });

    for (auto element : arr)
    {
        cout << element << endl;
    }
    */

    /*
    vector<int> v = { 9,4,94,6,1,3,7 };
    sort(v.begin(), v.end(), [](int a, int b) { return a > b; });    // предикат в виде lambda-функции
    
    // sort(v.begin(), v.end());
    // sort(v.begin(), v.end(), MyPred);   // может принимать 2 или 3 аргумента. Минимум - начало и конец коллекции STL

    for (auto element : v)
    {
        cout << element << endl;
    }
    */

    return 0;
}


###### STL алгоритмы поиска | find | find_if | find_if_not | Библиотека стандартных шаблонов (stl) C++ #14
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;

class Person
{
public:
    Person(string name, double score)
    {
        this->Name = name;
        this->Score = score;
    }

    bool operator ()(const Person &p)
    {
        return p.Score > 180;
    }

    string Name;
    double Score;
};


int main()
{
    setlocale(LC_ALL, "ru");

    vector<Person> people
    {
        Person("Вася",181),
        Person("Петя",30),
        Person("Маша",179),
        Person("Даша",200),
        Person("Катя",198),
        Person("Андрей",181),
        Person("Сергей",50),
        Person("Иван",150),
        Person("Иван",190),
        Person("Петя",10)
    };

    vector<int> v = { 6,4,4,12,10,2,70 };

    auto result = find_if(people.begin(), people.end(), [](const Person &p) { return p.Name == "Маша" && p.Score == 179; });
    // auto result = find_if(people.begin(), people.end(), [](const Person &p) { return p.Name == "Маша" || p.Score > 100; });

    if (result == people.end())
    {
        cout << "-" << endl;
    }
    else
    {
        cout << "+" << endl;
    }

    /*
    vector<int> v = { 6,4,4,12,10,2,70 };

    // auto result = find_if(v.begin(), v.end(), [](int a) { return a < 0; });  // find_if принимает унарный придикат

    // auto result = find_if_not(v.begin(), v.end(), [](int a) { return a < 0; });   // инвертированный find_if

    auto result = find(v.begin(), v.end(), 7);    // если элемента нет в коллекции, то функция find возвращает указатель на end()
    
    if (result == v.end())
    {
        cout << "-" << endl;
    }
    else
    {
        cout << "+" << endl;
    }
    */

    return 0;
}


###### stl copy | stl copy_if | Выборка данных по условию | Библиотека стандартных шаблонов (stl) C++ #15
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;

class Person
{
public:
    Person(string name, double score, int age)
    {
        this->Name = name;
        this->Score = score;
        this->Age = age;
    }

    bool operator ()(const Person &p)
    {
        return p.Score > 180;
    }

    string Name;
    double Score;
    int Age;
};


int main()
{
    setlocale(LC_ALL, "ru");

    vector<Person> people
    {
        Person("Вася",181,17),
        Person("Петя",30,22),
        Person("Маша",179,19),
        Person("Даша",200,25),
        Person("Катя",198,24),
        Person("Андрей",181,23),
        Person("Сергей",50,30),
        Person("Денис",180,40),
        Person("Иван",150,32),
        Person("Иван",199,31),
        Person("Петя",10,53)
    };

    vector<Person> result;   // коллекция, в которую мы будем копировать элементы коллекции

    copy_if(people.begin(), people.end(), back_inserter(result), [](const Person& p) { return p.Age > 25; });

    sort(result.begin(), result.end(), [](const Person& p1, const Person &p2) { return p1.Name < p2.Name; });
    
    cout << "Всего элементов:\t" << result.size() << endl;

    for (auto element : result)
    {
        cout << "Имя:\t" << element.Name << "\tбаллы:\t" << element.Score << "\tВозраст:\t" << element.Age << endl;
    }

    // copy(people.begin(), people.end(), back_inserter(result));   // просто копирует элементы. Третьим параметром - функция back_inserter

    return 0;
}


###### stl remove | stl remove_if | stl удаление элемента по условию | Библиотека (stl) #16


