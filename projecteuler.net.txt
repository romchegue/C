// https://projecteuler.net/

// File SimpleTimer.h
#pragma once
#include <iostream>
#include <chrono>

class SimpleTimer
{
public:
	SimpleTimer();
	~SimpleTimer();
private:
	std::chrono::time_point<std::chrono::steady_clock> start, end;
	std::chrono::duration<float> duration;
};


// File SimpleTimer.cpp
#include "SimpleTimer.h"

SimpleTimer::SimpleTimer()
{
	start = std::chrono::high_resolution_clock::now();
}

SimpleTimer::~SimpleTimer()
{
	end = std::chrono::high_resolution_clock::now();
	duration = end - start;
	std::cout << "\nDURATION: " << duration.count() << "s" << std::endl;
}


//###### Problem 1 - Multiples of 3 and 5
// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. 
// The sum of these multiples is 23.
// Find the sum of all the multiples of 3 or 5 below 1000.
#include <iostream>
#include "SimpleTimer.h"

double SumDivisbleBy(const int n, const int target)
{
	double p = target / n;
	return (double)(n * (p*(p+1)) / 2);
}

int main()
{
	SimpleTimer st;
	const int target = 999999999;
	
	/*
	double sum = 0;
	for (size_t i = 1; i <= target; i++)
	{
		if (i % 3 == 0 || i % 5 == 0)
		{
			sum += i;
		}
	}
	std::cout << sum << std::endl;
	*/

	std::cout << SumDivisbleBy(3, target) + SumDivisbleBy(5, target) - SumDivisbleBy(15, target) << std::endl;
	
	return 0;
}



//###### Problem 2 - Even Fibonacci numbers
// Each new term in the Fibonacci sequence is generated by adding the previous two terms.
// By starting with 1 and 2, the first 10 terms will be :
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, 
// find the sum of the even - valued terms.

#include <iostream>
#include "SimpleTimer.h"

int EvenFebonacciSum(const int upperBound)
{
	int sum = 0;
	int temp;
	int a = 1;
	int b = 1;

	while (b < upperBound)
	{
		if (b % 2 == 0)
		{
			std::cout << b << std::endl;
			sum += b;
		}
		temp = b;
		b += a;
		a = temp;
	}

	return sum;
}


int main()
{
	SimpleTimer st;
	
	const int upperBound = 4000000;

	std::cout << std::endl << EvenFebonacciSum(upperBound) << std::endl;
	return 0;
}


//###### Problem 3 - Largest prime factor
// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143 ?

#include <iostream>
#include <cmath>
#include "SimpleTimer.h"

bool IsPrime(int a)
{
	if (a <= 1)     // if number a less or equal 1 then return FALSE
	{
		return false;
	}

	for (int i = 2; i < sqrt(a) + 1; ++i)
	{
		if (a % i == 0) // in this case the number "number" is not prime
		{
			return false;
		}   
	}
	return true;
}

int nextPrime(int start)
{
	while (true)
	{
		if (IsPrime(start))    // the number "start" is prime
		{ 
			return start; 
		}  
		else                   // go to the next number
		{
			start++;
		}
	}
}

int main()
{
	SimpleTimer st;
	
	long long int number = 600851475143;
	int primeFactor = 2;
	int largestPrimeFactor;

	while (true)
	{
		if (number % primeFactor == 0)
		{
			largestPrimeFactor = primeFactor;
			std::cout << largestPrimeFactor << std::endl;
			if (number / primeFactor == 1)
			{
				break;
			}
			number /= primeFactor;
		}
		else
		{
			primeFactor = nextPrime(primeFactor + 1);
		}
	}

	std::cout << std::endl << largestPrimeFactor << std::endl;
	return 0;
}


//###### Problem 4 (NOT GOOD) - Largest palindrome product
// A palindromic number reads the same both ways. 
// The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit numbers.

#include <iostream>
#include <string>
#include "SimpleTimer.h"

int Strlen(const char *string)
{
    int i = 0;
    char ch = string[i];

    while (ch != '\0') { ch = string[++i]; }

    return i;
}

bool IsPalindromic(const char *string)
{
    int length = Strlen(string);

    int i = 0;             // a first element in the string
    int j = length - 1;    // a last element in the string

    for (i; i < length / 2; ++i, --j)
    {
        if (string[i] != string[j])
        {
            return false;
        }
    }

    return true;
}


int main()
{
    SimpleTimer timer;
    const int target = 999;
    int largestPolindrome = 0;
    int tempNum;
    std::string tempStr;

    for (int i = target; i > 99; --i)
    {
        for (int j = target; j > 99; --j)
        {
            tempNum = i * j;
            tempStr = std::to_string(tempNum);
            if (IsPalindromic(tempStr.c_str()))
            {
                if (tempNum > largestPolindrome)
                {
                    largestPolindrome = tempNum;
                    std::cout << "THE LARGEST POLINDROM IS: " << largestPolindrome << std::endl;
                }
                else
                {
                    break;
                }
            }
        }
    }


    std::cout << largestPolindrome << std::endl;
    return 0;
}


//###### Problem 4 - Largest palindrome product
// A palindromic number reads the same both ways. 
// The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit numbers.

#include <iostream>
#include "SimpleTimer.h"

int reverse(int num)
{
    int reversed = 0;
    while (num > 0)
    {
        reversed = 10 * reversed + num % 10;
        num /= 10;
    }
    return reversed;
}

bool isPalindrome(int num)
{
    return num == reverse(num);
}

int main()
{
    SimpleTimer timer;
    const int MIN = 100000;
    const int MAX = 999999;
    int largestPalindrome = 0;

    for (int i = MAX; i >= MIN; --i)
    {
        
        if (i % 10 == 0)   // a number that ends in 0 cannot be a palindrome
        {
            continue;
        }
        
        for (int j = i; j >= MIN; --j)
        {
            
            if (j % 10 == 0)   // a number that ends in 0 cannot be a palindrome
            {
                continue;
            }
            
            if (i * j <= largestPalindrome)   // numbers <= largestPolindrome are inappropriate
            {
                break;
            }

            if (isPalindrome(i * j))
            {
                largestPalindrome = i * j;
            }
        }
    }
    

    std::cout << largestPalindrome << std::endl;

    return 0;
}


//###### Problem 5 - Smallest multiple
// 2520 is the smallest number that can be divided by each 
// of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly 
// divisible by all of the numbers from 1 to 20?

#include <iostream>
#include "SimpleTimer.h"
#include <cmath>

bool isPrime(int num)
{
    for (size_t i = 2; i < (int)sqrt(num) + 1; ++i)
    {
        if (num % i == 0)
        {
            return false;
        }
    }

    return true;
}

long long int primeMux(int num, long long int res)
{
    long long int temp = res;
    const int MAX = (int)sqrt(num) + 1;

    for (size_t i = 2; i < MAX; ++i)
    {
        while (num % i == 0)
        {
            if (temp % i == 0)
            {
                temp /= i;
            }
            else
            {
                res *= i;
            }

            num /= i;
            if (num <= 1)
            {
                break;
            }
        }
    }
    
    return res;
}


// TEST OF THE PROGRAM SPEED:
void testMain(const char* msg)   
{
    SimpleTimer timer;
    long long int result = 1;
    const int MAX = 30;
    for (int i = 2; i <= MAX; ++i)
    {
        if (result % i == 0) continue;

        if (isPrime(i))
        {
            result *= i;
        }
        else
        {
            result = primeMux(i, result);
        }
    }
    std::cout << msg << "\tRESULT: " << result << std::endl;
}


int main()
{
    /*
    // TESTS OF THE PROGRAM SPEED
    char message[] = "TEST #2 (isPrime + primeMux + result % i)";
    
    for (size_t i = 0; i < 10; i++)
    {
        testMain(message);
    }
    */


    SimpleTimer timer;
    long long int result = 1;
    const int MAX = 30;
    for (int i = 2; i <= MAX; ++i)
    {
        
        if (isPrime(i))
        {
           result *= i;
        }
        else
        {
            result = primeMux(i, result);
        } 
    }

    std::cout << result << std::endl;
    
    return 0;
}




//###### Problem 5 - Smallest multiple
// 2520 is the smallest number that can be divided by each 
// of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly 
// divisible by all of the numbers from 1 to 20?

class PointerToArray 
{
public:
    PointerToArray(T* pointer, size_t size = 1) : this->pointer(pointer), this->size(size) {}
    PointerToArray(PointerToArray const& other) :pointer(other.pointer), size(other.size) {}
    T& operator  *()const { return  *pointer; }
    T* operator  ->()const { return  pointer; }
    T& operator [](size_t i)const { return *(pointer + i); }
    T* operator +(size_t i)const { return pointer + i; }
    T* begin()const { return pointer; }
    T* end()const { return pointer + size; }
    size_t size()const { return size; }
private:
    T* pointer;
    size_t size;
};


void g(PointerToArray<int> px) 
{
    std::cout << "size of array is " << px.size() << std::endl;
    std::cout << "px[5]==" << px[5] << std::endl;
    std::cout << "*(px+5)==" << (*(px + 5)) << std::endl;
}

//###### Problem 5 - Smallest multiple
// 2520 is the smallest number that can be divided by each 
// of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly 
// divisible by all of the numbers from 1 to 20?

#include <iostream>
#include "SimpleTimer.h"
#include <cmath>

bool isPrime(int num)
{
    for (size_t i = 2; i < (int)sqrt(num) + 1; ++i)
    {
        if (num % i == 0)
        {
            return false;
        }
    }

    return true;
}

void GetPrimeArray(int *arr, const int MAX)
{
    int index = 0;
    
    for (int i = 2; i <= MAX; ++i)   // fill an array of prime numbers <= MAX
    {
        if (isPrime(i))
        {
            arr[index] = i;
            ++index;
        }
    }

}

void TEST(const char* msg = "")
{
    SimpleTimer timer;

    long long int result = 1;
    int MAX = 30;
    int* primeArray = new int[MAX]{ 0 };

    int limit = (int)sqrt(MAX);

    GetPrimeArray(primeArray, MAX);    // generate an array of prime numbers <= MAX

    int i = 0;
    while (primeArray[i] != 0)
    {
        if (primeArray[i] <= limit)
        {
            int temp = int(log(MAX) / log(primeArray[i]));
            int temp1 = primeArray[i];
            result *= pow(temp1, temp);
        }
        else
        {
            result *= primeArray[i];
        }

        ++i;
    }

    delete[] primeArray;
    std::cout << msg << "\tRESULT: " << result << std::endl;
}

int main()
{
    /*
    for (size_t i = 0; i < 10; i++)
    {
        TEST("TEST #3 (GetPrimeArray)");
    }
    */

    
    SimpleTimer timer;

    long long int result = 1;
    int MAX = 20;
    int *primeArray = new int[MAX]{ 0 };
   
    int limit = (int)sqrt(MAX);
    
    GetPrimeArray(primeArray, MAX);    // generate an array of prime numbers <= MAX

    int i = 0;
    while (primeArray[i] != 0)
    {
        if (primeArray[i] <= limit)
        {
            int temp = int(log(MAX) / log(primeArray[i]));
            int temp1 = primeArray[i];
            result *= pow(temp1, temp);
        }
        else
        {
            result *= primeArray[i];
        }
        
        ++i;
    }

    std::cout << result << std::endl;
    
    delete[] primeArray;

    return 0;
}

 
//###### MY SIMPLE PROFILER

// File MyTools.h
#pragma once
#include <iostream>
#include <chrono>
#include <fstream>

// Function myProfiler takes 2 arguments: a function with type void and without argumets and a number of function calls
void myProfiler(void(*func)(), const int COUNT = 10, const char* MESSAGE = "", const char *FILENAME = "TEST_RESULTS.txt");   // this is a simple profiler



// File MyTools.cpp
#include "MyTools.h"

void myProfiler(void(*func)(), const int COUNT, const char *MESSAGE, const char *FILENAME)  
{
    std::ofstream fout;     // write to file:
    fout.open(FILENAME, std::ios_base::app);
    
    std::chrono::time_point<std::chrono::steady_clock> start, end;
    std::chrono::duration<float> sumDuration;

    start = std::chrono::high_resolution_clock::now();
    end = std::chrono::high_resolution_clock::now();
    sumDuration = end - start;

    for (size_t i = 0; i < COUNT; ++i)
    {
        start = std::chrono::high_resolution_clock::now();
        func();
        end = std::chrono::high_resolution_clock::now();

        sumDuration += end - start;
    }

    std::cout << std::endl << std::endl;
    if (MESSAGE != "") 
    { 
        std::cout << MESSAGE << std::endl; 
        fout << MESSAGE << std::endl;
    }
    std::cout << "Total code execution time " << COUNT << " times:\t" << sumDuration.count() << "s" << std::endl << std::endl;
    fout << "Total code execution time " << COUNT << " times:\t" << sumDuration.count() << "s" << std::endl << std::endl;

    fout.close();

    system("pause");
}


//###### Problem 6 - Sum square difference
// The sum of the squares of the first ten natural numbers is,
//     pow(1,2) + pow(2,2) + ... + pow(10,2) = 385
// The square of the sum of the first ten natural numbers is,
//     pow((1 + 2 + ... + 10), 2) = pow(55, 2) = 3025
// Hence the difference between the sum of the squares of the 
// first ten natural numbers and the square of the sum is 3025−385 = 2640.
// Find the difference between the sum of the squares of the first 
// one hundred natural numbers and the square of the sum.

#include <iostream>
#include <cmath>
#include "MyTools.h"


void TEST()
{
    int MAX = 100;
    
    __int64 sum = 0;
    __int64 sum_sq = 0;
    __int64 result;

    for (size_t i = 1; i <= MAX; ++i)
    {
        sum_sq += i * i;
        sum += i;
    }
    
    std::cout << sum * sum - sum_sq << std::endl;
}

int main()
{
    // myProfiler(TEST, 1000000, "Problem 6 - Sum square difference. [Simple version]");
    TEST();
    
    const int MAX = 100;

    __int64 sum = 0;
    __int64 sum_sq = 0;
    __int64 result;

    for (size_t i = 1; i <= MAX; ++i)
    {
        sum_sq += i * i;
        sum += i;
    }

    std::cout << sum * sum - sum_sq << std::endl;
    

    return 0;
}


##### Problem 6 - Sum square difference
// The sum of the squares of the first ten natural numbers is,
//     pow(1,2) + pow(2,2) + ... + pow(10,2) = 385
// The square of the sum of the first ten natural numbers is,
//     pow((1 + 2 + ... + 10), 2) = pow(55, 2) = 3025
// Hence the difference between the sum of the squares of the 
// first ten natural numbers and the square of the sum is 3025−385 = 2640.
// Find the difference between the sum of the squares of the first 
// one hundred natural numbers and the square of the sum.

#include <iostream>
#include <cmath>
#include "MyTools.h"


void TEST()
{
    int MAX = 100;
    
    __int64 sum = 0;
    __int64 sum_sq = 0;
    __int64 result;

    sum = (MAX * MAX + MAX) / 2;
    
    sum_sq = MAX * (MAX + 1) * (2 * MAX + 1) / 6;

    result = sum * sum - sum_sq;
    // std::cout << sum * sum - sum_sq << std::endl;
}

int main()
{
    myProfiler(TEST, 1000000, "Problem 6 - Sum square difference. [sum and sum_sq formulas. 10000]");
    // TEST();
    
    int MAX = 100;

    __int64 sum = 0;
    __int64 sum_sq = 0;
    __int64 result;

    sum = (MAX * MAX + MAX) / 2;

    sum_sq = MAX * (MAX + 1) * (2 * MAX + 1) / 6;

    result = sum * sum - sum_sq;
    std::cout << sum * sum - sum_sq << std::endl;
        
    return 0;
}


//###### Problem 7 - 10001st prime
// By listing the first six prime numbers: 
// 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
// What is the 10 001st prime number ?

#include <iostream>
#include <cmath>
#include "MyTools.h"

bool isPrime(__int64 num)
{
    int MAX = (int)sqrt(num) + 1;
    for (int i = 2; i < MAX; i++)
    {
        if (num % i == 0)
        {
            return false;
        }
    }

    return true;
}


void TEST()
{
    int counter = 3;    // prime numbers: 2,3,5
    const int limit = 10001;
    __int64 i = 0;
    __int64 lastPrime = 5;
    const int SIZE = 2;
    __int64 arr[SIZE];

    while (counter < limit)
    {
        ++i;
 
        arr[0] = 6 * i + 1;
        arr[1] = 6 * i + 5;
        
        for (int element : arr)
        {
            if (isPrime(element))
            {
                ++counter;
                lastPrime = element;
            }
            if (counter >= limit)
            {
                break;
            }
        }
        
    }
    
    // std::cout << lastPrime << std::endl;
}

int main()
{
    myProfiler(TEST, 1000, "Problem 7 - 10001st prime. [Version with 6k+1, 6k+5. 10001th]");
    // TEST();
        
    return 0;
}


//###### Problem 7 - 10001st prime
// By listing the first six prime numbers: 
// 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
// What is the 10 001st prime number ?

#include <iostream>
#include <cmath>
#include "MyTools.h"

bool isPrime(__int64 num)
{
    int MAX = (int)sqrt(num) + 1;
    for (int i = 2; i < MAX; i++)
    {
        if (num % i == 0)
        {
            return false;
        }
    }

    return true;
}

__int64 primeOrder(const int N)
{   // determines approximate size of N-th integer
    // info: https://primes.utm.edu/howmany.html#better 
    
    __int64 pN;

    if (N <= 0)
    {
        return 0;
    }

    if (N < 13)
    {
        pN = 38;     // 12th prime number is 37
        return pN;
    }

    if (N >= 13 && N < 8601)                      // p(N) ~ N * (ln(N) + ln(ln(N)) - 1)
    {
        pN = N * (log(N) + log(log(N)) - 1);
        return pN;
    }

    if (N >= 8601 && N < 15985)   // N * (ln(N) + ln(ln(N)) - 1.0073) < p(N) < N * (ln(N) + ln(ln(N)) - 0.9385)
    {
        pN = N * (log(N) + log(log(N)) - 0.9385);   // upoper bound of the division
        return pN;
    }

    if (N >= 15985)   // p(N) <= N * (ln(N) + ln(ln(N)) - 0.9427)
    {
        pN = N * (log(N) + log(log(N)) - 0.9385);   // upper bound of the division
        return pN;
    }
}

void Eratosthen(bool *arr, const int limit)     
{   // Algorithm - Sieve of Eratosthenes
    // https://younglinux.info/algorithm/sieve
    arr[0] = arr[1] = false;

    for (int i = 2; i * i < limit; ++i)
    {
        if (arr[i])
        {
            for (int j = i * i; j < limit; j += i)
            {
                arr[j] = false;
            }
        }
    }
}


int main()
{
    int N = 10001;
    int limit = primeOrder(N);
    bool* arr = new bool[limit + 1];
    int counter = 0;
    int result = 0;

    for (int i = 0; i <= limit; ++i) { arr[i] = true; }  

    Eratosthen(arr, limit);

    for (int i = 2; i <= limit; ++i)
    {
        if (arr[i])
        {
            ++counter;
        }
        if (counter == N)
        {
            result += i;
            break;
        }
    }
    std::cout << result << std::endl;

    delete[] arr;
    return 0;
}


//###### Problem 7 - 10001st prime - THE ANSWER
// By listing the first six prime numbers: 
// 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
// What is the 10 001st prime number ?

#include <iostream>
#include <cmath>
#include "MyTools.h"

bool isPrimeNew(__int64 n)
{
    if (n <= 1) { return false; }            // numbers <= 1 are not prime
    else if (n < 4) { return true; }        // 2 and 3 are prime
    else if (n % 2 == 0) { return false; }   // even numbers are not prime
    else if (n < 9) { return true; }        // we have alraedy excluded 4, 6 and 8
    else if (n % 3 == 0) { return false; }
    else
    {
        int r = floor(sqrt(n));    // r is rounded to the greatest integer r so that r*r<=n
        int f = 5;    // 6k - 1, k = 1

        while (f <= r) 
        {
            if (n % f == 0)         // f = 6k - 1
            {
                return false;
            }
            if (n % (f + 2) == 0)   // f + 2 == 6k + 1
            {
                return false;
            }
            f += 6;     // ++k
        }
        return true;        // in all other cases
    }
}


int main()
{
    int limit =10001;
    int count = 1;       // we know that 2 is prime
    int candidate = 1;
    
    while(count < limit)
    {
        candidate += 2;
        if (isPrimeNew(candidate))
        {
            count++;
        }
    }
    
    std::cout << candidate << std::endl;

    return 0;
}


//###### Problem 8 - Largest product in a series
// The four adjacent digits in the 1000-digit number that 
// have the greatest product are 9 × 9 × 8 × 9 = 5832.
/*
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450
*/
// Find the thirteen adjacent digits in the 1000-digit 
// number that have the greatest product. What is the value of this product?

#include <iostream>
#include <cmath>
#include <string>
#include <fstream>
#include "MyTools.h"

void readFromFile(std::string &text, const char *path = "input.txt")
{
    std::ifstream fin;
    std::string tmp;
    text = "";
    
    try
    {
        fin.open(path);

        while (!fin.eof())
        {
            fin >> tmp;
            text += tmp;
        }
    }
    catch (const std::ifstream::failure &ex)
    {
        std::cout << ex.what() << std::endl;
        std::cout << ex.code() << std::endl;
        std::cout << "[ERROR!] The file is not opened!" << std::endl;
    }

    fin.close();
}

long long int arrayProduct(const char *arr, const int SIZE)
{     // This function will return the sum (!!!) of all digits in the array becuse of max type size is __int64 - not enough
    long long int product = 1;
    for (long long int i = 0; i < SIZE; i++)
    {
        if (arr[i] == '0')        // if one of the digits is 0 then the product will equal 0
        {
            return 0;
        }
        product *= (int)arr[i] - 48;    // ANSI code of '0' = 48
    }
    
    return product;
}

char* arrayCopy(const char* arr, const int SIZE)
{
    char* tmp = new char[SIZE];
    for (int i = 0; i < SIZE; i++)
    {
        tmp[i] = arr[i];
    }
    return tmp;
}

void TEST()
{
    std::string text;
    readFromFile(text);    
    // cin >> text;
    
    int textSize = text.size();
    long long int largestProduct = 0;
    long long int tempProduct = 0;
    int adjacentCount = 13;

    char* adjacentBlock = new char[adjacentCount];
    char* largestBlock = new char[adjacentCount];
    
    int i = 0;
    bool exit = false;
    while (true)
    {

        for (int j = 0; j < adjacentCount; ++j)
        {
            adjacentBlock[j] = text[j + i];
            
            if (adjacentBlock[j] == '\0')
            {
                exit = true;
                break;
            }
        }

        if (exit) { break; };

        tempProduct = arrayProduct(adjacentBlock, adjacentCount);
        if (tempProduct > largestProduct)
        {
            largestProduct = tempProduct;
            largestBlock = arrayCopy(adjacentBlock, adjacentCount);
        }
        ++i;
    }

    
    for (int i = 0; i < adjacentCount; i++)
    {
        // largestBlock[i];
        std::cout << largestBlock[i] << " ";
    }
    std::cout << std::endl;
    

    delete[] adjacentBlock;
    delete[] largestBlock;
}

int main()
{
    // TEST();
    myProfiler(TEST, 1000, "Problem 8 - Largest product in a series [Simple version #1]");

    return 0;
}


//###### Problem 9 - Special Pythagorean triplet
// A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
//     a^2 + b^2 = c^2
// For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
// There exists exactly one Pythagorean triplet for which a + b + c = 1000.
// Find the product abc.

#include <iostream>
#include <fstream>
#include "MyTools.h"


int GCD(int a, int b)     // Greater Common Divisor
{
    while (a != 0 and b != 0)
    {
        if (a > b)
        {
            a = a % b;
        }
        else
        {
            b = b % a;
        }
    }

    return a + b;
}

void myDecision()
{
    int a, b, c = 3;    // a < b < c
    int sumABC = 1000;
    bool flag = false;

    for (a = sumABC / 4 - 1; a > 1; --a)
    {
        for (b = sumABC / 2 - 1; b > 2; --b)
        {
            c = sumABC - a - b;

            if (c * c == (a * a + b * b))
            {
                flag = true;
                break;
            }
        }

        if (flag) { break; }
    }

    std::cout << a << ", " << b << ", " << c << "\n";
    std::cout << a * b * c << "\n";
}


void projecteuler_1()
{
    int a, b, c = 3;    // a < b < c
    int s = 1000;

    for (a = 3; a <= (s - 3) / 3; ++a)
    {
        for (b = (a + 1); b <= (s - 1 - a) / 2; ++b)
        {
            c = s - a - b;
            if (c*c == a*a + b*b)
            {
                std::cout << a << ", " << b << ", " << c << "\n";
                std::cout << a * b * c << "\n";
            }
        }
    }
}


void projecteuler_2()
{
    int a, b, c, s, s2, n, m, sm, k, d;
    s = 1000;
    s2 = s / 2;

    for (m = 2; m < ceil(sqrt(s2)) + 1; ++m)
    {
        if (s2 % m == 0)
        {
            sm = s2 / m;
            while (sm % 2 == 0) { sm /= 2; }       // reduce the search space by removing all factors 2
            
            if (m % 2 == 1) { k = m + 2; } else { k = m + 1; }

            while (k < 2 * m && k <= sm)
            {
                if (sm % k == 0 && GCD(k, m) == 1)
                {
                    d = s2 / (k * m);
                    n = k - m;
                    a = 2 * d * m * n;
                    b = d * (m * m - n * n);
                    c = d * (m * m + n * n);

                    //std::cout << a << ", " << b << ", " << c << "\n";
                    //std::cout << a * b * c << "\n";
                    return;
                }
                k += 2;
            }
        }
    }
}



int main()
{
    setlocale(LC_ALL, "rus");
    myProfiler(projecteuler_2, 1000, "Problem 9 - Special Pythagorean triplet [The project version #2]");
   // projecteuler_2();

    return 0;
}


//###### Problem 10 - Summation of primes
// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
// Find the sum of all the primes below two million.

#include <iostream>
#include <cmath>
#include "MyTools.h"

void Eratosphen(bool *isPrime, const long long int N)
{
    for (long long int i = 0; i < N + 1; ++i)
    {
        isPrime[i] = true;
    }

    isPrime[0] = false;
    isPrime[1] = false;

    for (long long int i = 2; i*i < N; ++i)
    {
        if (isPrime[i])
        {
            for (long long int j = i*i; j <= N; j += i)
            {
                isPrime[j] = false;
            }
        }
    }


}

void TEST()
{
    long long int N = 2000000;
    bool *arr = new bool [N+1];
    Eratosphen(arr, N);
    long long int sum = 0;

    for (long long int i = 0; i <= N; ++i)
    {
        if (arr[i])
        {
            sum += i;
        }
    }
    std::cout << "The sum of primes up to " << N << " equals:\n" << sum << "\n";
}

int main()
{
    // myProfiler(TEST, 1, "Problem 10 - Summation of primes. [My version #1]");
    TEST();

    return 0;
}


//###### Problem 10 - Summation of primes
// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
// Find the sum of all the primes below two million.

#include <iostream>
#include <cmath>
#include "MyTools.h"

void Eratosphen(bool *isPrime, const long long int N)
{
    for (long long int i = 0; i < N + 1; ++i)
    {
        isPrime[i] = true;
    }
    
    isPrime[0] = false;
    isPrime[1] = false;

    for (int i = 4; i <= N; i += 2)     // Exclude all the even numbers
    {
        isPrime[i] = false;
    }

    for (long long int i = 3; i*i <= N; i += 2)    // The step equals 2
    {
        if (isPrime[i])
        {
            for (long long int j = i*i; j <= N; j += (2 * i))    // step = 2 * i
            {
                isPrime[j] = false;
            }
        }
    }


}


void TEST()
{
    long long int N = 2000000;
    bool *arr = new bool [N+1];
    Eratosphen(arr, N);
    long long int sum = 0;
    /*
    //////////////////////////////////////////
    for (int i = 0; i <= N; ++i)
    {
        std::cout << arr[i] << " "; 
    }
    std::cout << "\n\n";
    //////////////////////////////////////////
    */
    for (long long int i = 0; i <= N; ++i)
    {
        if (arr[i])
        {
            sum += i;
        }
    }
    //std::cout << "The sum of primes up to " << N << " equals:\n" << sum << "\n";
}

int main()
{
    myProfiler(TEST, 1, "Problem 10 - Summation of primes. [My version #1]");
    //TEST();

    return 0;
}



//###### Problem 10 - Summation of primes
// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
// Find the sum of all the primes below two million.

#include <iostream>
#include <cmath>
#include "MyTools.h"
/*
void Eratosphen(bool *isPrime, const long long int N)
{
    for (long long int i = 0; i < N + 1; ++i)
    {
        isPrime[i] = true;
    }

    int limit = (int)sqrt(N);
    isPrime[0] = false;
    isPrime[1] = false;

    for (int i = 4; i <= N; i += 2)     // even numbers > 2
    {
        isPrime[i] = false;
    }

    for (long long int i = 3; i <= limit; i += 2)
    {
        if (isPrime[i])
        {
            for (long long int j = i*i; j <= N; j += 2 * i)
            {
                isPrime[j] = false;
            }
        }
    }
}

void TEST()
{
    long long int N = 2000000;
    bool *arr = new bool [N+1];
    Eratosphen(arr, N);
    long long int sum = 0;

    for (long long int i = 0; i <= N; ++i)
    {
        if (arr[i])
        {
            sum += i;
        }
    }
    std::cout << "The sum of primes up to " << N << " equals:\n" << sum << "\n";
}
*/
void Eratosphen2(const long long int limit)
{
    long long int sievebound = (limit - 1) / 2;      // last index of sieve
    bool *sieve = new bool[sievebound + 1];                // sieve - bool array of size = (sievebound + 1)
    for (long long int i = 0; i <= sievebound; ++i)  // fill sieve with FALSEs
    {
        sieve[i] = false;
    }
    int crosslimit = ((int)sqrt(limit) - 1) / 2;     // the limit of cross for prime numbers

    for (int i = 1; i <= crosslimit; ++i)
    {
        if (!sieve[i])       // if (2*i+1) is primw, then mark all its multiples
        {
            for (long long int j = 2 * i * (i + 1);  j <= sievebound; j += 2 * i + 1)
            {
                sieve[j] = true;
            }
        }
    }

    long long int sum = 2;       // 2 is prime
    for (long long int i = 1; i <+ sievebound; ++i)
    {
        if (!sieve[i])
        {
            sum += 2 * i + 1;
        }
    }

    //std::cout << sum << "\n";
}

void TEST1()
{
    long long int N = 2000000;

    Eratosphen2(N);
}

int main()
{
    myProfiler(TEST1, 1, "Problem 10 - Summation of primes. [ProjectEuler.net version #2]");
    //TEST1();

    return 0;
}