// https://projecteuler.net/

// File SimpleTimer.h
#pragma once
#include <iostream>
#include <chrono>

class SimpleTimer
{
public:
	SimpleTimer();
	~SimpleTimer();
private:
	std::chrono::time_point<std::chrono::steady_clock> start, end;
	std::chrono::duration<float> duration;
};


// File SimpleTimer.cpp
#include "SimpleTimer.h"

SimpleTimer::SimpleTimer()
{
	start = std::chrono::high_resolution_clock::now();
}

SimpleTimer::~SimpleTimer()
{
	end = std::chrono::high_resolution_clock::now();
	duration = end - start;
	std::cout << "\nDURATION: " << duration.count() << "s" << std::endl;
}


//###### Problem 1 - Multiples of 3 and 5
// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. 
// The sum of these multiples is 23.
// Find the sum of all the multiples of 3 or 5 below 1000.
#include <iostream>
#include "SimpleTimer.h"

double SumDivisbleBy(const int n, const int target)
{
	double p = target / n;
	return (double)(n * (p*(p+1)) / 2);
}

int main()
{
	SimpleTimer st;
	const int target = 999999999;
	
	/*
	double sum = 0;
	for (size_t i = 1; i <= target; i++)
	{
		if (i % 3 == 0 || i % 5 == 0)
		{
			sum += i;
		}
	}
	std::cout << sum << std::endl;
	*/

	std::cout << SumDivisbleBy(3, target) + SumDivisbleBy(5, target) - SumDivisbleBy(15, target) << std::endl;
	
	return 0;
}



//###### Problem 2 - Even Fibonacci numbers
// Each new term in the Fibonacci sequence is generated by adding the previous two terms.
// By starting with 1 and 2, the first 10 terms will be :
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, 
// find the sum of the even - valued terms.

#include <iostream>
#include "SimpleTimer.h"

int EvenFebonacciSum(const int upperBound)
{
	int sum = 0;
	int temp;
	int a = 1;
	int b = 1;

	while (b < upperBound)
	{
		if (b % 2 == 0)
		{
			std::cout << b << std::endl;
			sum += b;
		}
		temp = b;
		b += a;
		a = temp;
	}

	return sum;
}


int main()
{
	SimpleTimer st;
	
	const int upperBound = 4000000;

	std::cout << std::endl << EvenFebonacciSum(upperBound) << std::endl;
	return 0;
}


//###### Problem 3 - Largest prime factor
// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143 ?

#include <iostream>
#include <cmath>
#include "SimpleTimer.h"

bool IsPrime(int a)
{
	if (a <= 1)     // if number a less or equal 1 then return FALSE
	{
		return false;
	}

	for (int i = 2; i < sqrt(a) + 1; ++i)
	{
		if (a % i == 0) // in this case the number "number" is not prime
		{
			return false;
		}   
	}
	return true;
}

int nextPrime(int start)
{
	while (true)
	{
		if (IsPrime(start))    // the number "start" is prime
		{ 
			return start; 
		}  
		else                   // go to the next number
		{
			start++;
		}
	}
}

int main()
{
	SimpleTimer st;
	
	long long int number = 600851475143;
	int primeFactor = 2;
	int largestPrimeFactor;

	while (true)
	{
		if (number % primeFactor == 0)
		{
			largestPrimeFactor = primeFactor;
			std::cout << largestPrimeFactor << std::endl;
			if (number / primeFactor == 1)
			{
				break;
			}
			number /= primeFactor;
		}
		else
		{
			primeFactor = nextPrime(primeFactor + 1);
		}
	}

	std::cout << std::endl << largestPrimeFactor << std::endl;
	return 0;
}


//###### Problem 4 (NOT GOOD) - Largest palindrome product
// A palindromic number reads the same both ways. 
// The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit numbers.

#include <iostream>
#include <string>
#include "SimpleTimer.h"

int Strlen(const char *string)
{
    int i = 0;
    char ch = string[i];

    while (ch != '\0') { ch = string[++i]; }

    return i;
}

bool IsPalindromic(const char *string)
{
    int length = Strlen(string);

    int i = 0;             // a first element in the string
    int j = length - 1;    // a last element in the string

    for (i; i < length / 2; ++i, --j)
    {
        if (string[i] != string[j])
        {
            return false;
        }
    }

    return true;
}


int main()
{
    SimpleTimer timer;
    const int target = 999;
    int largestPolindrome = 0;
    int tempNum;
    std::string tempStr;

    for (int i = target; i > 99; --i)
    {
        for (int j = target; j > 99; --j)
        {
            tempNum = i * j;
            tempStr = std::to_string(tempNum);
            if (IsPalindromic(tempStr.c_str()))
            {
                if (tempNum > largestPolindrome)
                {
                    largestPolindrome = tempNum;
                    std::cout << "THE LARGEST POLINDROM IS: " << largestPolindrome << std::endl;
                }
                else
                {
                    break;
                }
            }
        }
    }


    std::cout << largestPolindrome << std::endl;
    return 0;
}


//###### Problem 4 - Largest palindrome product
// A palindromic number reads the same both ways. 
// The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit numbers.

#include <iostream>
#include "SimpleTimer.h"

int reverse(int num)
{
    int reversed = 0;
    while (num > 0)
    {
        reversed = 10 * reversed + num % 10;
        num /= 10;
    }
    return reversed;
}

bool isPalindrome(int num)
{
    return num == reverse(num);
}

int main()
{
    SimpleTimer timer;
    const int MIN = 100000;
    const int MAX = 999999;
    int largestPalindrome = 0;

    for (int i = MAX; i >= MIN; --i)
    {
        
        if (i % 10 == 0)   // a number that ends in 0 cannot be a palindrome
        {
            continue;
        }
        
        for (int j = i; j >= MIN; --j)
        {
            
            if (j % 10 == 0)   // a number that ends in 0 cannot be a palindrome
            {
                continue;
            }
            
            if (i * j <= largestPalindrome)   // numbers <= largestPolindrome are inappropriate
            {
                break;
            }

            if (isPalindrome(i * j))
            {
                largestPalindrome = i * j;
            }
        }
    }
    

    std::cout << largestPalindrome << std::endl;

    return 0;
}


//###### Problem 5 - Smallest multiple
// 2520 is the smallest number that can be divided by each 
// of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly 
// divisible by all of the numbers from 1 to 20?

#include <iostream>
#include "SimpleTimer.h"
#include <cmath>

bool isPrime(int num)
{
    for (size_t i = 2; i < (int)sqrt(num) + 1; ++i)
    {
        if (num % i == 0)
        {
            return false;
        }
    }

    return true;
}

long long int primeMux(int num, long long int res)
{
    long long int temp = res;
    const int MAX = (int)sqrt(num) + 1;

    for (size_t i = 2; i < MAX; ++i)
    {
        while (num % i == 0)
        {
            if (temp % i == 0)
            {
                temp /= i;
            }
            else
            {
                res *= i;
            }

            num /= i;
            if (num <= 1)
            {
                break;
            }
        }
    }
    
    return res;
}


// TEST OF THE PROGRAM SPEED:
void testMain(const char* msg)   
{
    SimpleTimer timer;
    long long int result = 1;
    const int MAX = 30;
    for (int i = 2; i <= MAX; ++i)
    {
        if (result % i == 0) continue;

        if (isPrime(i))
        {
            result *= i;
        }
        else
        {
            result = primeMux(i, result);
        }
    }
    std::cout << msg << "\tRESULT: " << result << std::endl;
}


int main()
{
    /*
    // TESTS OF THE PROGRAM SPEED
    char message[] = "TEST #2 (isPrime + primeMux + result % i)";
    
    for (size_t i = 0; i < 10; i++)
    {
        testMain(message);
    }
    */


    SimpleTimer timer;
    long long int result = 1;
    const int MAX = 30;
    for (int i = 2; i <= MAX; ++i)
    {
        
        if (isPrime(i))
        {
           result *= i;
        }
        else
        {
            result = primeMux(i, result);
        } 
    }

    std::cout << result << std::endl;
    
    return 0;
}




//###### Problem 5 - Smallest multiple
// 2520 is the smallest number that can be divided by each 
// of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly 
// divisible by all of the numbers from 1 to 20?

class PointerToArray 
{
public:
    PointerToArray(T* pointer, size_t size = 1) : this->pointer(pointer), this->size(size) {}
    PointerToArray(PointerToArray const& other) :pointer(other.pointer), size(other.size) {}
    T& operator  *()const { return  *pointer; }
    T* operator  ->()const { return  pointer; }
    T& operator [](size_t i)const { return *(pointer + i); }
    T* operator +(size_t i)const { return pointer + i; }
    T* begin()const { return pointer; }
    T* end()const { return pointer + size; }
    size_t size()const { return size; }
private:
    T* pointer;
    size_t size;
};


void g(PointerToArray<int> px) 
{
    std::cout << "size of array is " << px.size() << std::endl;
    std::cout << "px[5]==" << px[5] << std::endl;
    std::cout << "*(px+5)==" << (*(px + 5)) << std::endl;
}

//###### Problem 5 - Smallest multiple
// 2520 is the smallest number that can be divided by each 
// of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly 
// divisible by all of the numbers from 1 to 20?

#include <iostream>
#include "SimpleTimer.h"
#include <cmath>

bool isPrime(int num)
{
    for (size_t i = 2; i < (int)sqrt(num) + 1; ++i)
    {
        if (num % i == 0)
        {
            return false;
        }
    }

    return true;
}

void GetPrimeArray(int *arr, const int MAX)
{
    int index = 0;
    
    for (int i = 2; i <= MAX; ++i)   // fill an array of prime numbers <= MAX
    {
        if (isPrime(i))
        {
            arr[index] = i;
            ++index;
        }
    }

}

void TEST(const char* msg = "")
{
    SimpleTimer timer;

    long long int result = 1;
    int MAX = 30;
    int* primeArray = new int[MAX]{ 0 };

    int limit = (int)sqrt(MAX);

    GetPrimeArray(primeArray, MAX);    // generate an array of prime numbers <= MAX

    int i = 0;
    while (primeArray[i] != 0)
    {
        if (primeArray[i] <= limit)
        {
            int temp = int(log(MAX) / log(primeArray[i]));
            int temp1 = primeArray[i];
            result *= pow(temp1, temp);
        }
        else
        {
            result *= primeArray[i];
        }

        ++i;
    }

    delete[] primeArray;
    std::cout << msg << "\tRESULT: " << result << std::endl;
}

int main()
{
    /*
    for (size_t i = 0; i < 10; i++)
    {
        TEST("TEST #3 (GetPrimeArray)");
    }
    */

    
    SimpleTimer timer;

    long long int result = 1;
    int MAX = 20;
    int *primeArray = new int[MAX]{ 0 };
   
    int limit = (int)sqrt(MAX);
    
    GetPrimeArray(primeArray, MAX);    // generate an array of prime numbers <= MAX

    int i = 0;
    while (primeArray[i] != 0)
    {
        if (primeArray[i] <= limit)
        {
            int temp = int(log(MAX) / log(primeArray[i]));
            int temp1 = primeArray[i];
            result *= pow(temp1, temp);
        }
        else
        {
            result *= primeArray[i];
        }
        
        ++i;
    }

    std::cout << result << std::endl;
    
    delete[] primeArray;

    return 0;
}


