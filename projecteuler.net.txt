// https://projecteuler.net/

// File SimpleTimer.h
#pragma once
#include <iostream>
#include <chrono>

class SimpleTimer
{
public:
	SimpleTimer();
	~SimpleTimer();
private:
	std::chrono::time_point<std::chrono::steady_clock> start, end;
	std::chrono::duration<float> duration;
};


// File SimpleTimer.cpp
#include "SimpleTimer.h"

SimpleTimer::SimpleTimer()
{
	start = std::chrono::high_resolution_clock::now();
}

SimpleTimer::~SimpleTimer()
{
	end = std::chrono::high_resolution_clock::now();
	duration = end - start;
	std::cout << "\nDURATION: " << duration.count() << "s" << std::endl;
}


//###### Problem 1 - Multiples of 3 and 5
// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. 
// The sum of these multiples is 23.
// Find the sum of all the multiples of 3 or 5 below 1000.
#include <iostream>
#include "SimpleTimer.h"

double SumDivisbleBy(const int n, const int target)
{
	double p = target / n;
	return (double)(n * (p*(p+1)) / 2);
}

int main()
{
	SimpleTimer st;
	const int target = 999999999;
	
	/*
	double sum = 0;
	for (size_t i = 1; i <= target; i++)
	{
		if (i % 3 == 0 || i % 5 == 0)
		{
			sum += i;
		}
	}
	std::cout << sum << std::endl;
	*/

	std::cout << SumDivisbleBy(3, target) + SumDivisbleBy(5, target) - SumDivisbleBy(15, target) << std::endl;
	
	return 0;
}



//###### Problem 2 - Even Fibonacci numbers
// Each new term in the Fibonacci sequence is generated by adding the previous two terms.
// By starting with 1 and 2, the first 10 terms will be :
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, 
// find the sum of the even - valued terms.

#include <iostream>
#include "SimpleTimer.h"

int EvenFebonacciSum(const int upperBound)
{
	int sum = 0;
	int temp;
	int a = 1;
	int b = 1;

	while (b < upperBound)
	{
		if (b % 2 == 0)
		{
			std::cout << b << std::endl;
			sum += b;
		}
		temp = b;
		b += a;
		a = temp;
	}

	return sum;
}


int main()
{
	SimpleTimer st;
	
	const int upperBound = 4000000;

	std::cout << std::endl << EvenFebonacciSum(upperBound) << std::endl;
	return 0;
}


//###### Problem 3 - Largest prime factor
// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143 ?

#include <iostream>
#include <cmath>
#include "SimpleTimer.h"

bool IsPrime(int a)
{
	if (a <= 1)     // if number a less or equal 1 then return FALSE
	{
		return false;
	}

	for (int i = 2; i < sqrt(a) + 1; ++i)
	{
		if (a % i == 0) // in this case the number "number" is not prime
		{
			return false;
		}   
	}
	return true;
}

int nextPrime(int start)
{
	while (true)
	{
		if (IsPrime(start))    // the number "start" is prime
		{ 
			return start; 
		}  
		else                   // go to the next number
		{
			start++;
		}
	}
}

int main()
{
	SimpleTimer st;
	
	long long int number = 600851475143;
	int primeFactor = 2;
	int largestPrimeFactor;

	while (true)
	{
		if (number % primeFactor == 0)
		{
			largestPrimeFactor = primeFactor;
			std::cout << largestPrimeFactor << std::endl;
			if (number / primeFactor == 1)
			{
				break;
			}
			number /= primeFactor;
		}
		else
		{
			primeFactor = nextPrime(primeFactor + 1);
		}
	}

	std::cout << std::endl << largestPrimeFactor << std::endl;
	return 0;
}


//###### Problem 4 (NOT GOOD) - Largest palindrome product
// A palindromic number reads the same both ways. 
// The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit numbers.

#include <iostream>
#include <string>
#include "SimpleTimer.h"

int Strlen(const char *string)
{
    int i = 0;
    char ch = string[i];

    while (ch != '\0') { ch = string[++i]; }

    return i;
}

bool IsPalindromic(const char *string)
{
    int length = Strlen(string);

    int i = 0;             // a first element in the string
    int j = length - 1;    // a last element in the string

    for (i; i < length / 2; ++i, --j)
    {
        if (string[i] != string[j])
        {
            return false;
        }
    }

    return true;
}


int main()
{
    SimpleTimer timer;
    const int target = 999;
    int largestPolindrome = 0;
    int tempNum;
    std::string tempStr;

    for (int i = target; i > 99; --i)
    {
        for (int j = target; j > 99; --j)
        {
            tempNum = i * j;
            tempStr = std::to_string(tempNum);
            if (IsPalindromic(tempStr.c_str()))
            {
                if (tempNum > largestPolindrome)
                {
                    largestPolindrome = tempNum;
                    std::cout << "THE LARGEST POLINDROM IS: " << largestPolindrome << std::endl;
                }
                else
                {
                    break;
                }
            }
        }
    }


    std::cout << largestPolindrome << std::endl;
    return 0;
}


//###### Problem 4 - Largest palindrome product
// A palindromic number reads the same both ways. 
// The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit numbers.

#include <iostream>
#include "SimpleTimer.h"

int reverse(int num)
{
    int reversed = 0;
    while (num > 0)
    {
        reversed = 10 * reversed + num % 10;
        num /= 10;
    }
    return reversed;
}

bool isPalindrome(int num)
{
    return num == reverse(num);
}

int main()
{
    SimpleTimer timer;
    const int MIN = 100000;
    const int MAX = 999999;
    int largestPalindrome = 0;

    for (int i = MAX; i >= MIN; --i)
    {
        
        if (i % 10 == 0)   // a number that ends in 0 cannot be a palindrome
        {
            continue;
        }
        
        for (int j = i; j >= MIN; --j)
        {
            
            if (j % 10 == 0)   // a number that ends in 0 cannot be a palindrome
            {
                continue;
            }
            
            if (i * j <= largestPalindrome)   // numbers <= largestPolindrome are inappropriate
            {
                break;
            }

            if (isPalindrome(i * j))
            {
                largestPalindrome = i * j;
            }
        }
    }
    

    std::cout << largestPalindrome << std::endl;

    return 0;
}


//###### Problem 5 - Smallest multiple
// 2520 is the smallest number that can be divided by each 
// of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly 
// divisible by all of the numbers from 1 to 20?

#include <iostream>
#include "SimpleTimer.h"
#include <cmath>

bool isPrime(int num)
{
    for (size_t i = 2; i < (int)sqrt(num) + 1; ++i)
    {
        if (num % i == 0)
        {
            return false;
        }
    }

    return true;
}

long long int primeMux(int num, long long int res)
{
    long long int temp = res;
    const int MAX = (int)sqrt(num) + 1;

    for (size_t i = 2; i < MAX; ++i)
    {
        while (num % i == 0)
        {
            if (temp % i == 0)
            {
                temp /= i;
            }
            else
            {
                res *= i;
            }

            num /= i;
            if (num <= 1)
            {
                break;
            }
        }
    }
    
    return res;
}


// TEST OF THE PROGRAM SPEED:
void testMain(const char* msg)   
{
    SimpleTimer timer;
    long long int result = 1;
    const int MAX = 30;
    for (int i = 2; i <= MAX; ++i)
    {
        if (result % i == 0) continue;

        if (isPrime(i))
        {
            result *= i;
        }
        else
        {
            result = primeMux(i, result);
        }
    }
    std::cout << msg << "\tRESULT: " << result << std::endl;
}


int main()
{
    /*
    // TESTS OF THE PROGRAM SPEED
    char message[] = "TEST #2 (isPrime + primeMux + result % i)";
    
    for (size_t i = 0; i < 10; i++)
    {
        testMain(message);
    }
    */


    SimpleTimer timer;
    long long int result = 1;
    const int MAX = 30;
    for (int i = 2; i <= MAX; ++i)
    {
        
        if (isPrime(i))
        {
           result *= i;
        }
        else
        {
            result = primeMux(i, result);
        } 
    }

    std::cout << result << std::endl;
    
    return 0;
}




//###### Problem 5 - Smallest multiple
// 2520 is the smallest number that can be divided by each 
// of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly 
// divisible by all of the numbers from 1 to 20?

class PointerToArray 
{
public:
    PointerToArray(T* pointer, size_t size = 1) : this->pointer(pointer), this->size(size) {}
    PointerToArray(PointerToArray const& other) :pointer(other.pointer), size(other.size) {}
    T& operator  *()const { return  *pointer; }
    T* operator  ->()const { return  pointer; }
    T& operator [](size_t i)const { return *(pointer + i); }
    T* operator +(size_t i)const { return pointer + i; }
    T* begin()const { return pointer; }
    T* end()const { return pointer + size; }
    size_t size()const { return size; }
private:
    T* pointer;
    size_t size;
};


void g(PointerToArray<int> px) 
{
    std::cout << "size of array is " << px.size() << std::endl;
    std::cout << "px[5]==" << px[5] << std::endl;
    std::cout << "*(px+5)==" << (*(px + 5)) << std::endl;
}

//###### Problem 5 - Smallest multiple
// 2520 is the smallest number that can be divided by each 
// of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly 
// divisible by all of the numbers from 1 to 20?

#include <iostream>
#include "SimpleTimer.h"
#include <cmath>

bool isPrime(int num)
{
    for (size_t i = 2; i < (int)sqrt(num) + 1; ++i)
    {
        if (num % i == 0)
        {
            return false;
        }
    }

    return true;
}

void GetPrimeArray(int *arr, const int MAX)
{
    int index = 0;
    
    for (int i = 2; i <= MAX; ++i)   // fill an array of prime numbers <= MAX
    {
        if (isPrime(i))
        {
            arr[index] = i;
            ++index;
        }
    }

}

void TEST(const char* msg = "")
{
    SimpleTimer timer;

    long long int result = 1;
    int MAX = 30;
    int* primeArray = new int[MAX]{ 0 };

    int limit = (int)sqrt(MAX);

    GetPrimeArray(primeArray, MAX);    // generate an array of prime numbers <= MAX

    int i = 0;
    while (primeArray[i] != 0)
    {
        if (primeArray[i] <= limit)
        {
            int temp = int(log(MAX) / log(primeArray[i]));
            int temp1 = primeArray[i];
            result *= pow(temp1, temp);
        }
        else
        {
            result *= primeArray[i];
        }

        ++i;
    }

    delete[] primeArray;
    std::cout << msg << "\tRESULT: " << result << std::endl;
}

int main()
{
    /*
    for (size_t i = 0; i < 10; i++)
    {
        TEST("TEST #3 (GetPrimeArray)");
    }
    */

    
    SimpleTimer timer;

    long long int result = 1;
    int MAX = 20;
    int *primeArray = new int[MAX]{ 0 };
   
    int limit = (int)sqrt(MAX);
    
    GetPrimeArray(primeArray, MAX);    // generate an array of prime numbers <= MAX

    int i = 0;
    while (primeArray[i] != 0)
    {
        if (primeArray[i] <= limit)
        {
            int temp = int(log(MAX) / log(primeArray[i]));
            int temp1 = primeArray[i];
            result *= pow(temp1, temp);
        }
        else
        {
            result *= primeArray[i];
        }
        
        ++i;
    }

    std::cout << result << std::endl;
    
    delete[] primeArray;

    return 0;
}

 
//###### MY SIMPLE PROFILER

// File MyTools.h
#pragma once
#include <iostream>
#include <chrono>
#include <fstream>

// Function myProfiler takes 2 arguments: a function with type void and without argumets and a number of function calls
void myProfiler(void(*func)(), const int COUNT = 10, const char* MESSAGE = "", const char *FILENAME = "TEST_RESULTS.txt");   // this is a simple profiler



// File MyTools.cpp
#include "MyTools.h"

void myProfiler(void(*func)(), const int COUNT, const char *MESSAGE, const char *FILENAME)  
{
    std::ofstream fout;     // write to file:
    fout.open(FILENAME, std::ios_base::app);
    
    std::chrono::time_point<std::chrono::steady_clock> start, end;
    std::chrono::duration<float> sumDuration;

    start = std::chrono::high_resolution_clock::now();
    end = std::chrono::high_resolution_clock::now();
    sumDuration = end - start;

    for (size_t i = 0; i < COUNT; ++i)
    {
        start = std::chrono::high_resolution_clock::now();
        func();
        end = std::chrono::high_resolution_clock::now();

        sumDuration += end - start;
    }

    std::cout << std::endl << std::endl;
    if (MESSAGE != "") 
    { 
        std::cout << MESSAGE << std::endl; 
        fout << MESSAGE << std::endl;
    }
    std::cout << "Total code execution time " << COUNT << " times:\t" << sumDuration.count() << "s" << std::endl << std::endl;
    fout << "Total code execution time " << COUNT << " times:\t" << sumDuration.count() << "s" << std::endl << std::endl;

    fout.close();

    system("pause");
}


//###### Problem 6 - Sum square difference
// The sum of the squares of the first ten natural numbers is,
//     pow(1,2) + pow(2,2) + ... + pow(10,2) = 385
// The square of the sum of the first ten natural numbers is,
//     pow((1 + 2 + ... + 10), 2) = pow(55, 2) = 3025
// Hence the difference between the sum of the squares of the 
// first ten natural numbers and the square of the sum is 3025−385 = 2640.
// Find the difference between the sum of the squares of the first 
// one hundred natural numbers and the square of the sum.

#include <iostream>
#include <cmath>
#include "MyTools.h"


void TEST()
{
    int MAX = 100;
    
    __int64 sum = 0;
    __int64 sum_sq = 0;
    __int64 result;

    for (size_t i = 1; i <= MAX; ++i)
    {
        sum_sq += i * i;
        sum += i;
    }
    
    std::cout << sum * sum - sum_sq << std::endl;
}

int main()
{
    // myProfiler(TEST, 1000000, "Problem 6 - Sum square difference. [Simple version]");
    TEST();
    
    const int MAX = 100;

    __int64 sum = 0;
    __int64 sum_sq = 0;
    __int64 result;

    for (size_t i = 1; i <= MAX; ++i)
    {
        sum_sq += i * i;
        sum += i;
    }

    std::cout << sum * sum - sum_sq << std::endl;
    

    return 0;
}


##### Problem 6 - Sum square difference
// The sum of the squares of the first ten natural numbers is,
//     pow(1,2) + pow(2,2) + ... + pow(10,2) = 385
// The square of the sum of the first ten natural numbers is,
//     pow((1 + 2 + ... + 10), 2) = pow(55, 2) = 3025
// Hence the difference between the sum of the squares of the 
// first ten natural numbers and the square of the sum is 3025−385 = 2640.
// Find the difference between the sum of the squares of the first 
// one hundred natural numbers and the square of the sum.

#include <iostream>
#include <cmath>
#include "MyTools.h"


void TEST()
{
    int MAX = 100;
    
    __int64 sum = 0;
    __int64 sum_sq = 0;
    __int64 result;

    sum = (MAX * MAX + MAX) / 2;
    
    sum_sq = MAX * (MAX + 1) * (2 * MAX + 1) / 6;

    result = sum * sum - sum_sq;
    // std::cout << sum * sum - sum_sq << std::endl;
}

int main()
{
    myProfiler(TEST, 1000000, "Problem 6 - Sum square difference. [sum and sum_sq formulas. 10000]");
    // TEST();
    
    int MAX = 100;

    __int64 sum = 0;
    __int64 sum_sq = 0;
    __int64 result;

    sum = (MAX * MAX + MAX) / 2;

    sum_sq = MAX * (MAX + 1) * (2 * MAX + 1) / 6;

    result = sum * sum - sum_sq;
    std::cout << sum * sum - sum_sq << std::endl;
        
    return 0;
}


//###### Problem 7 - 10001st prime
// By listing the first six prime numbers: 
// 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
// What is the 10 001st prime number ?

#include <iostream>
#include <cmath>
#include "MyTools.h"

bool isPrime(__int64 num)
{
    int MAX = (int)sqrt(num) + 1;
    for (int i = 2; i < MAX; i++)
    {
        if (num % i == 0)
        {
            return false;
        }
    }

    return true;
}


void TEST()
{
    int counter = 3;    // prime numbers: 2,3,5
    const int limit = 10001;
    __int64 i = 0;
    __int64 lastPrime = 5;
    const int SIZE = 2;
    __int64 arr[SIZE];

    while (counter < limit)
    {
        ++i;
 
        arr[0] = 6 * i + 1;
        arr[1] = 6 * i + 5;
        
        for (int element : arr)
        {
            if (isPrime(element))
            {
                ++counter;
                lastPrime = element;
            }
            if (counter >= limit)
            {
                break;
            }
        }
        
    }
    
    // std::cout << lastPrime << std::endl;
}

int main()
{
    myProfiler(TEST, 1000, "Problem 7 - 10001st prime. [Version with 6k+1, 6k+5. 10001th]");
    // TEST();
        
    return 0;
}


//###### Problem 7 - 10001st prime
// By listing the first six prime numbers: 
// 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
// What is the 10 001st prime number ?

#include <iostream>
#include <cmath>
#include "MyTools.h"

bool isPrime(__int64 num)
{
    int MAX = (int)sqrt(num) + 1;
    for (int i = 2; i < MAX; i++)
    {
        if (num % i == 0)
        {
            return false;
        }
    }

    return true;
}

__int64 primeOrder(const int N)
{   // determines approximate size of N-th integer
    // info: https://primes.utm.edu/howmany.html#better 
    
    __int64 pN;

    if (N <= 0)
    {
        return 0;
    }

    if (N < 13)
    {
        pN = 38;     // 12th prime number is 37
        return pN;
    }

    if (N >= 13 && N < 8601)                      // p(N) ~ N * (ln(N) + ln(ln(N)) - 1)
    {
        pN = N * (log(N) + log(log(N)) - 1);
        return pN;
    }

    if (N >= 8601 && N < 15985)   // N * (ln(N) + ln(ln(N)) - 1.0073) < p(N) < N * (ln(N) + ln(ln(N)) - 0.9385)
    {
        pN = N * (log(N) + log(log(N)) - 0.9385);   // upoper bound of the division
        return pN;
    }

    if (N >= 15985)   // p(N) <= N * (ln(N) + ln(ln(N)) - 0.9427)
    {
        pN = N * (log(N) + log(log(N)) - 0.9385);   // upper bound of the division
        return pN;
    }
}

void Eratosthen(bool *arr, const int limit)     
{   // Algorithm - Sieve of Eratosthenes
    // https://younglinux.info/algorithm/sieve
    arr[0] = arr[1] = false;

    for (int i = 2; i * i < limit; ++i)
    {
        if (arr[i])
        {
            for (int j = i * i; j < limit; j += i)
            {
                arr[j] = false;
            }
        }
    }
}


int main()
{
    int N = 10001;
    int limit = primeOrder(N);
    bool* arr = new bool[limit + 1];
    int counter = 0;
    int result = 0;

    for (int i = 0; i <= limit; ++i) { arr[i] = true; }  

    Eratosthen(arr, limit);

    for (int i = 2; i <= limit; ++i)
    {
        if (arr[i])
        {
            ++counter;
        }
        if (counter == N)
        {
            result += i;
            break;
        }
    }
    std::cout << result << std::endl;

    delete[] arr;
    return 0;
}


